# 💡 CH10. 일급 함수 (1)

## 👻 함수 이름에 있는 암묵적 인자

### 🔎 특징

    1. 함수 구현이 거의 똑같다. (코드의 중복)

    2. 함수 이름이 구현의 차이를 만든다.
        - 필드를 결정하는 문자열이 함수 이름에 있다.
        - 함수 이름에 있는 일부가 인자처럼 동작한다.
        - 함수 이름에서 서로 다른 부분이 암묵적 인자가 된다.
        - 값을 명시적으로 전달하지 않고 함수 이름의 일부로 전달하고 있다.

## 👾 암묵적 인자를 드러내기

### ⚒️ 리팩터링 단계

    1. 함수에 있는 암묵적 인자를 확인한다.

    2. 명시적인 인자를 추가한다.

    3. 함수 본문에 하드 코딩된 값을 새로운 인자로 바꾼다.

    4. 함수를 부르는 곳을 고친다.

### 💫 일급 값

- 언어에 있는 다른 값처럼 쓸 수 있는 것
- 언어 전체에 어디서나 쓸 수 있음
- 암묵적인 인자가 인자로 넘길 수 있는 값이 되고, 이는 변수나 배열에 담을 수 있음
- 예: JS의 숫자, 문자열, boolean 값, 배열, 객체, 함수 등

<br/>

> JS에서 일급이 아닌 것

1. 수식 연산자
2. 반복문
3. 조건문
4. try ~ catch 블록
5. 함수명
   - 일부를 값처럼 쓸 수 없으므로 일부를 인자로 바꿔 일급으로 만들어야 함

<br/>

    🌟  특징
        - 함수의 인자로 넘길 수 없음
        - 변수에 할당할 수 없음

<br/>

> 일급으로 할 수 있는 것

1. 변수에 할당하기
2. 함수의 인자로 넘기기
3. 함수의 리턴값으로 받기
4. 배열이나 객체에 담기

### 🤔 필드명을 문자열로 사용하면 버그가 생기지 않을까?

**_만약 문자열에 오타가 있다면?_**

> 해결 방법1 - **컴파일 타임**에 검사하기

- 주로 정적 타입 시스템에서 사용하는 방법
- 예: TypeScript로 문자열이 사용할 수 있는 필드인지 확인하기

<br/>

> 해결 방법2 - **런타임**에 검사하기

- 컴파일 타임에는 동작하지 않다가 함수를 실행할 때마다 동작함
- JS는 정적 타입 언어가 아니므로 이 방법을 사용!

### 🤔 일급 필드를 사용하면 API를 바꾸기 더 어려울까?

    엔티티 필드명을 일급으로 만들어 사용하면 세부 구현을 노출시키게 되지 않나?
    추상화 벽 아래에서 정의한 필드명이 벽 위로 전달되면 원칙을 위반하는 것이 아닌가?
    API 문서에 필드명을 명시하면 영원히 수정이 불가능하지 않은가?

- 필드명을 계속 유지해야 하는 것은 맞음
- 구현이 외부에 노출된 것은 아님
  - 내부에서 정의한 필드명이 바뀌어도 사용하는 사람들은 원래 필드명을 그대로 사용할 수 있음
  - 내부에서 그냥 수정해주면 됨

### 🚨 객체와 배열을 너무 많이 쓰게 된다!

> 데이터 지향

- 이벤트와 엔티티에 대한 사실을 표현하기 위해 일반 데이터 구조를 사용하는 프로그래밍 형식
- 데이터를 데이터 그대로 사용하기
  - 데이터를 임의의 인터페이스로 감싸지 않고 그대로 사용하기
    - 인터페이스를 만들면 데이터를 정해진 방법으로만 쓸 수 있음
    - 일반적인 엔티티는 객체와 배열처럼 일반적인 데이터 구조를 사용해야 함
      - 일반적이고 재사용할 수 있어야하기 때문!
      - 커스텀 API처럼 구체적인 것이 아니라 호출 그래프 상 낮은 곳에 위치하는 엔티티들은 일반적이므로 인터페이스로 감싸면 역할이 한정됨
  - 여러 가지 방법으로 해석할 수 있음
  - 데이터가 미래에 어떤 방법으로 해석될지 미리 알 수 없으므로 필요할 때 알맞은 방법으로 해석할 수 있어야 함

### 정적타입 🤼 동적타입

> 정적 타입

- 컴파일 시 타입을 검사하는 언어

> 동적 타입

- 런타임에 타입을 확인하는 언어
- JS

### 💫 모두 문자열로 통신한다!

- 많은 동적 타입 언어가 데이터 구조의 필드를 문자열로 표현하고 전송함
  - JS, 루비, 클로저, 파이썬
- 클라이언트 -(JSON)→ 서버, 서버 -(JSON)→ API, 서버 -(SQL)→ DB 모두 문자열로 통신
  - 웹 브라우저는 서버로 JSON을 보내고, 서버는 이 문자열을 받아 해석하면서 JSON이 올바를 것이라고 기대함
  - 만약 올바른 JSON 문서라면 데이터 구조를 이해할 수 있을 것으로 기대됨
  - 웹 서버는 DB로 명령어를 전달하기 위해 문자열로 직렬화함
  - DB는 받은 명령어를 해석하고 실행함
- 데이터 형식에 타입이 있다고 해도 바이트일 뿐!
- 잘못된 문자열이 들어갈 위험성이 있음
  - API는 클라이언트에게 받은 데이터를 런타임에 체크해야 함

**_데이터는 항상 해석이 필요하다!_**

## 🤖 함수 본문을 콜백으로 바꾸기

### ⚒️ 반복문을 일급 값으로 만들기

> 고차 함수

- 인자로 함수를 받거나 리턴하는 값으로 함수를 리턴할 수 있는 함수
- **일급**은 인자로 전달할 수 있음을, **고차**는 함수가 다른 함수를 인자로 받을 수 있음을 의미
- 일급 함수가 없다면 고차 함수를 만들 수 없음

> 익명 함수

- 이름이 없는 함수
- 필요한 곳에 인라인으로 쓸 수 있음

### 🎣 try/catch 함수 본문을 콜백으로 바꾸기

> 콜백

- JS에서 인자로 전달하는 함수
- 나중에 호출될 것을 기대하고 콜백으로 전달함
- 핸들러 함수라고도 불림

> 인라인

- 쓰는 곳에서 바로 정의하는 함수
- 예: 인자 목록에서 바로 정의하는 함수

> 함수를 정의하는 방법 세 가지

#### 1. 전역으로 정의하기

- 함수를 전역적으로 정의하고 이룸 붙이기
- 함수 정의 시 가장 많이 사용되는 방법

```js
function setData(data) {
  return data;
}

setData("123");
```

#### 2. 지역적으로 정의하기

- 함수를 지역 범위 안에서 정의하고 이룸 붙이기
- 이름을 가지고 있지만 범위 밖에서는 사용 불가능
- 지역적으로 쓰고 싶지만 이름이 필요할 때 사용

```js
function setData(data) {
  const saveData = function (data) {
    result.push(data);
  };
  return afterSave(saveData(data))

setData("123");
```

#### 3. 인라인으로 정의하기

- 함수를 사용하는 곳에서 바로 정의하기
- 함수를 변수 같은 곳에 넣지 않기 때문에 **익명 함수** (이름 X)
- 문맥에서 한 번만 쓰는 짧은 함수에 쓰면 좋음

```js
function setData(data) {
  return data;
}

setData("123");
```

### 🤔 왜 본문을 함수로 감싸서 넘길까?

```js
function withLogging(f) {
  try {
    f();
  } catch (error) {
    logToSnapErrors(error);
  }
}

// 왜 함수를 만들어 이 코드를 감쌌을까?

withLogging(() => {
  saveUserData(user);
});
```

- 코드가 바로 실행되면 안 되기 때문!
- 함수를 감싸면 호출 전까지 실행되지 않으므로 이 방법으로 함수의 실행을 미룰 수 있음
- JS에서 함수는 일급이므로 여러 방법으로 정의 가능

  - 이름 붙이기: <code> const newFunc = () => {saveData(data)};</code>

  - 컬렉션에 저장하기: <code> array.push(() => {saveData(data)});</code>

  - 그냥 넘기기: <code>getData(() => {saveData(data)})</code>

- 익명함수는 다양한 방식으로 호출될 수 있음

  - 선택적으로 호출하기

    ```js
    function callLater(func) {
      if (isOpen) func();
    }
    ```

  - 나중에 호출하기

    ```js
    function callLater(func) {
      setTimeout(() => func(), 1500);
    }
    ```

  - 새로운 문맥 안에서 호출하기
    ```js
    function callLater(func) {
      try {
        func();
      } catch (err) {
        console.error(err);
      }
    }
    ```
