# 💡 CH7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

## 🚨 레거시 코드와 불변성

> 레거시 코드

- 오래전에 만든 것으로, 지금 당장 고칠 수 없어서 그대로 사용해야 하는 코드
- 잘 동작하긴 하지만 당장 리팩토링할 시간이 없을 때, 레거시 코드에 사용할 수 있는 안전한 인터페이스 要

```js
function add_item_to_cart(name, price) {
  var item = make_cart_item(name, price);
  shopping_cart = add_item(shopping_cart, item);
  var total = calc_total(shopping_cart);
  set_cart_total_dom(total);
  update_shipping_icons(shopping_cart);
  update_tax_dom(total);
  // 추가된 함수 호출 시 copy-on-write 원칙을 지킬 수 없게 됨
  // 또한, 해당 함수를 수정할 수도 없는 상황이라면?
  // 이때 사용하는 것이 방어적 복사!(아래에서 자세히 다룰 예정)
  black_friday_promotion(shopping_cart);
}
```

<br/>

### 📢 Copy-On-Write 코드는 신뢰할 수 없는 코드와 상호작용해야 함

- <code>black_friday_promotion( )</code>은 불변성이 지켜지는 안전지대 밖에 있는 함수

- 안전지대 밖의 함수의 입출력값을 불변성이 지켜지는 코드에서 사용해야 함

- 신뢰할 수 없는 코드는 데이터를 바꿀 수 있고, 따라서 안전지대로 들어오는 데이터도 잠재적으로 변경될 수 있음

- 데이터가 바뀌기 전 복사하여 데이터를 예측 가능한 copy-on-write 패턴이 적용된 함수와 달리,
  <code>black_friday_promotion( )</code>는 데이터 변경 시점을 정확히 파악하기 어려움

- 이때, 데이터가 바뀌는 것을 방지할 수 있도록 해주는 것이 🌟**방어적 복사**🌟
  - 방어적: 원본이 바뀌지 않도록 막아줌

<br/>

## 🖨️ 방어적 복사

    안전지대에 있는 원본 데이터의 불변성을 유지하고,
    바뀔 수도 있는 데이터가 안전지대로 들어오지 못하도록 하는 것이 방어적 복사의 목적!

<br/>

### 📢 방어적 복사는 원본이 바뀌는 것을 막아준다!

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/d5701f45-0f20-4ce0-80a2-d2b7860bd88b" width="40%">

<br/>

> 신뢰할 수 있는 데이터

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/5fa46c6c-1dfc-4b76-a572-f446ac4ce106" width="40%">

<br/>

1. 바뀔 수도 있는 데이터가 신뢰할 수 없는 코드에서 안전지대로 들어옴
   - 신뢰할 수 없는 코드가 해당 데이터에 대한 참조를 가지고 있음
2. 들어온 데이터로 깊은 복사본을 만들고 변경 가능한 원본은 버림
   - 신뢰할 수 있는 코드만 복사본을 사용하므로 원본 데이터가 바뀌지 않음
   - 안전지대에서는 변경 가능한 원본은 무시하고 깊은 복사로 만든 복사본을 사용하므로
     신뢰할 수 없는 코드 부분의 원본 데이터는 안전지대 내에서 데이터가 수정되어도 영향을 받지 않음

<br/>

> 안전지대에 있는 데이터

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/3e2428f6-cfa8-4286-9096-ebab707d2829" width="40%">

<br/>

1. 변경 불가능한 데이터를 내보내기 위해, 해당 데이터를 깊은 복사함
2. 깊은 복사를 통해 생성된 복사본을 안전지대에서 내보냄
   - 원본은 안전지대에 있고, 복사본이 신뢰할 수 없는 코드 부분으로 들어감
   - 따라서 데이터가 바뀌어도 원본 데이터는 영향을 받지 않음

<br/>

### 📑 방어적 복사의 규칙

> 데이터가 안전한 코드에서 나갈 때 복사하기

: 변경 불가능한 데이터가 신뢰할 수 없는 코드로 나갈 때, 원본 데이터를 보호하는 방법

1. 불변성 데이터를 위한 깊은 복사본 만들기

2. 신뢰할 수 없는 코드로 복사본 전달하기

> 안전한 코드로 데이터가 들어올 때 복사하기

: 신뢰할 수 없는 코드에서 변경될 수도 있는 데이터가 들어올 때, 안전한 코드를 보호하는 방법

1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달하기

2. 복사본을 안전한 코드에서 사용하기

<br/>

    🌟 깊은 복사 (Deep Copy)
        : 위부터 아래까지 모든 계층에 있는 중첩된 데이터 구조를 복사함

<br/>

### 🗂️ 방어적 복사의 사례

> 웹 API 속에서의 방어적 복사

- 대부분의 웹 기반 API는 암묵적으로 방어적 복사 수행
  - 클라이언트는 인터넷을 통해 API로 데이터를 보내기 위해 직렬화 함
    - 이때의 JSON 데이터는 깊은 복사본
  - 서비스가 잘 동작할 경우 API도 JSON으로 응답을 보냄
    - 이때의 JSON 역시 깊은 복사본
- 마이크로서비스나 서비스 지향 시스템은 양방향 통신 시 방어적 복사를 수행함
  - 마이크로서비스
    - 소프트웨어가 '잘 정의된 API를 통해 통신하는 소규모의 독립적인 서비스'로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식
  - 서비스 지향 시스템 (SOA)
    - 네트워크에서 공통의 통신 언어를 사용하는 서비스 인터페이스를 활용하여 소프트웨어 구성 요소를 다시 사용할 수 있게 만드는 소프트웨어 설계 유형
  - 이를 통해 서로 다른 코드와 원칙을 가진 서비스들이 문제 없이 통신 가능

<br/>

    🌟 비공유 아키텍쳐
        - 모듈이 서로 통신하기 위해 방어적 복사를 구현한 경우
        - 모듈이 어떤 데이터의 참조도 공유하고 있지 않게 됨
        - copy-on-write로 작성된 코드에 신뢰할 수 없는 코드의 참조를 공유하지 않을 수 있음

> Erlang, Elixir에서의 방어적 복사

- Erlang, Elixir: 함수형 프로그래밍 언어

- Erlang
  - 두 프로세스가 서로 메세지를 주고받는 경우 수신자의 메일박스에 메시지가 복사됨
  - 또한, 프로세스에서 데이터가 나갈 때도 데이터를 복사함
  - 방어적 복사를 통해 Erlang 시스템은 고가용성 보장

<br/>

### 🧐 QnA

> 동시에 사용자 데이터의 복사본 여러 개가 존재해도 괜찮을까?

- 함수형 프로그래밍에서, **_사용자_** 는 유일한 객체로 표현되지 않음
- 대신 사용자에 대한 **_데이터_** 를 처리하고 기록함 - 데이터: 이벤트에 대한 **_사실_** - 이벤트에 대해서 발생한 사실에 대한 기록이며, 이는 필요할 때마다 여러번 복사할 수 있음
  <br/>

> copy-on-write와 방어적 복사 중 하나만 사용하면 안 되나?

- 둘 다 불변성 유지를 위해 사용되므로 유사하게 기능함
- 하지만 깊은 복사는 얕은 복사보다 더 많은 비용이 듦
- 안전지대 내에서는 연산, 메모리 낭비를 막기 위해 copy-on-write를 사용해주는 것이 좋음
- 즉 두 원칙은 함께 사용되어야 함

<br/>

## 🤼 Copy-On-Write VS. 방어적 복사

|           |                                Copy-On-Write                                |                                                    방어적 복사                                                    |
| :-------: | :-------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------: |
|   언제    |                       통제할 수 있는 데이터를 바꿀 때                       |                                 신뢰할 수 없는 코드와 데이터를 주고 받아야 할 때                                  |
|  어디서   |    안전지대의 모든 부분 <br/> (copy-on-write가 안전지대를 생성하기 때문)    |                                      안전지대의 경계에서 데이터가 오고 갈 때                                      |
| 복사 방식 |                 얕은 복사 <br/> (상대적으로 적은 비용 소모)                 |                                    깊은 복사 <br/> (상대적으로 많은 비용 소모)                                    |
|   규칙    | 1. 바꿀 데이터의 얕은 복사본 생성 <br/> 2. 복사본 변경 <br/> 3. 복사본 리턴 | 1. 안전지대로 들어오는 데이터에 대한 깊은 복사본 생성 <br/> 2. 안전지대에서 나가는 데이터에 대한 깊은 복사본 생성 |

### 💸 깊은 복사는 얕은 복사보다 비싸다!

> 얕은 복사

- 바뀐 부분만 복사함
- 바뀌지 않은 값이라면 원본과 복사본이 데이터를 공유함
- 복사본과 원본 데이터 구조가 많은 부분을 공유하기 때문에 상대적으로 적은 비용 소모

> 깊은 복사

- 원본과 어떤 데이터 구조도 공유하지 않고, 중첩된 모든 객체나 배열을 복사함
- 데이터가 변경되면 안 되는데, 신뢰할 수 있는 코드 부분에서 변경될 가능성이 있을 때 사용
  - 공유하는 데이터 구조가 없기 때문에 신뢰할 수 없는 코드로부터 원본 데이터를 보호할 수 있기 때문
  - 비공유 아키텍쳐 구현에 용이

### 🤯 JS에서 깊은 복사를 구현하는 것은 어렵다!

- JS는 표준 라이브러리가 좋지 않아 깊은 복사를 구현하기 어려움
- Object.assign()과 전개연산자
  - 1 레벨의 depth에서는 효과적으로 깊은 복사 수행
  - 하지만 한 단계까지의 깊은 복사만 가능하고 그 이상의 depth부터는 얕은 복사 수행
- <code>Lodash.cloneDeep()</code> 함수 사용을 추천 (in Lodash)
  - 중첩된 데이터에 대한 깊은 복사 수행

<details>
<summary>코드 예시</summary>
<div markdown="1">

```js
const User = {
  first: {
    id: "aaa",
    pw: "aaa123",
  },
  second: {
    id: "bbb",
    pw: "bbb456",
  },
  third: "ccc",
};

const newUser = _.cloneDeep(User);

console.log(User === newUser); // false
console.log(User.first === newUser.first); // false
console.log(User.third === newUser.third); // false
```

</div>
</details>

<br/>
