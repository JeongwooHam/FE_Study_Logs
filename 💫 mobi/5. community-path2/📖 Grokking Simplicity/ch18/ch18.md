# 💡 CH18. 반응형 아키텍쳐와 어니언 아키텍쳐

```
두 개의 결합된 액션에서,
하나의 액션이 수정되면 결합된 다른 액션의 모든 것을 변경하거나 복제해야하는 문제가 생기는 경우가 있다.
🤔 이를 어떻게 해결할 수 있을까?
```

## ⚒️ 반응형 아키텍처

- 애플리케이션을 구조화는 방법
- 순차적 액션 단계에 사용
- 코드에 나타난 순차적 액션의 순서를 뒤집는다.
- 효과와 그 효과에 대한 원인을 분리하여 코드의 복잡한 부분을 풀 수 있다.
- **이벤트에 대한 반응으로 일어날 일을 지정한다.**
- 웹 서비스와 UI에 잘 어울린다.
  - 웹 서비스: 웹 요청 응답에 일어날 일을 지정한다.
  - UI: 버튼 클릭과 같은 이벤트 응답에 일어날 일을 지정한다. ➡️ **_EVENT HANDLER_**

### 🤖 이벤트 핸들러의 동작 과정

1. X, Y, Z, A, B, C를 순서대로 수행할 경우 반응형 아키텍처는 하려고 하는 것만 처리한다.
2. 모든 것은 어떤 일이 일어나면 그에 대한 응답으로 처리한다.
   - X가 일어나면 Y, Y가 일어나면 Z, ...

> 이벤트 핸들러 예제

|                              웹 서비스                              |                  사용자 인터페이스                   |
| :-----------------------------------------------------------------: | :--------------------------------------------------: |
|                           **요청 핸들러**                           |                  **이벤트 핸들러**                   |
|             핸들러는 웹 요청에 대한 응답으로 동작한다.              |     핸들러는 UI 이벤트에 대한 응답으로 동작한다.     |
| DB에서 가격 읽기, 장바구니 가격 변경, <br/> 합계 합산, 웹 응답 전송 | 전역 장바구니에 제품 추가, <br/> DOM/아이콘 업데이트 |

- 원래 핸들러 함수에서 순서대로 실행되던 것을 여러 개의 핸들러에서 실행되도록 나눈 것!

### 🗝️ 반응형 아키텍처의 절충점

- 반응형 아키텍처는 코드에 나타난 순차적 액션의 순서를 뒤집는다.
  - 예) X를 하고 Y를 하는 대신, X가 일어나면 언제나 Y를 한다.
- 코드의 가독성이 쉬워지고 유지보수에 용이하다.
- 언제, 어떻게 사용할지는 스스로 판단해야 한다.

### 💫 함수형 프로그래밍과 변경 가능한 상태

> 👀 **감시자(watcher)**

- 상태가 바뀔 때마다 실행되는 핸들러 함수
- ≒ 이벤트 핸들러, 옵저버, 콜백, 리스너

<hr/>

- <code>ValueCell</code>과 <code>FormulaCell</code>은 **액션** 이다.
  - 상태를 바꾼다.
  - 부르는 시점과 횟수가 중요하다.
- 모든 소프트웨어는 변경 가능한 상태를 잘 관리해야 한다.
- 새로운 사용자와 사용자의 행동을 파악하는 것이 중요하다.
- 상태가 어디에 있는지(외부 DB? 메모리?)는 중요하지 않다.

➡️ **_중요한 것은 상태를 가능한 한 안전하게 사용하는 것!_**

- 셀은 전역변수보다 안전하다.
  - 변경 불가능한 변수에 값을 담아두기 때문!
- <code>ValueCell</code>은 다른 타임라인에서 읽거나 쓰는 순서까지 보장하지는 않는다.
  - 그러나 어떤 값이 저장되어도 항상 올바른 값임을 보장하므로 사용하기에 좋다.
- 다른 함수형 언어, 프레임워크에서 <code>ValueCell</code>처럼 기능하는 것
  - 클로저의 <code>Atom</code>
  - 엘릭서의 <code>Agent</code>
  - 리액트의 <code>Redux Store</code>, <code>Recoil atom</code>
  - 하스켈의 <code>TVar</code>

> <code>ValueCell</code>을 일관되게 유지하려면?

1. 올바른 값으로 초기화하기

2. <code>update()</code>에 계산 전달하기

- <code>ValueCell.update(f)</code>
- 액션을 전달하지 않도록 주의할 것!

3. 올바른 값이 주어진 경우, 계산이 올바른 값을 리턴하는지 확인하기

```
👩‍🏫 반응형 아키텍처는 코드에 어떤 영향을 미쳤을까요?
```

### 1️⃣ 원인과 효과가 결합된 것을 분리한다.

```
상황에 따라 원인과 효과를 분리하는 것이 가독성을 떨어트릴 수도 있고, 코드를 유연하고 명확하게 만들수도 있다.
```

- 일반적인 아키텍쳐에서는, 제품을 추가할 때 뿐만 아니라 삭제 및 초기화 시에도 장바구니가 바뀌고 배송 아이콘을 항상 갱신해야 한다.

  - 장바구니를 바꾸는 모든 UI 이벤트 핸들러에 동일한 코드 작성 필요
  - 버튼 클릭(원인)과 배송 아이콘 갱신(효과)이 결합

- 반응형 아이콘을 통해 원인과 효과가 결합한 것을 분리 가능
  - 어떤 원인에 의해 장바구니가 변경되더라도 배송 아이콘을 갱신한다.
  - 배송 아이콘 갱신 코드는 한 번만 작성하면 된다.

> 결합의 분리는 원인와 효과의 중심을 관리한다.

| 장바구니를 바꾸는 방법                                                                         | 장바구니가 바뀔 때 해야 할 액션                                                                  |
| :--------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------- |
| - 제품 추가 <br/> - 제품 삭제 <br/> - 장바구니 비우기 <br/> - 수량 변경 <br/> - 할인 코드 적용 | - 배송 아이콘 업데이트 <br/> - 세금 표시 <br/> - 합계 표시 <br/> - 장바구니에 제품 개수 업데이트 |

- 위의 경우 장바구니가 바뀔 때 해야 할 일 추가 시 장바구니를 바꾸는 코드를 모두 고쳐야 한다. (반대의 경우도 마찬가지!)
- 원인과 결과가 모두 연관되면 관리해야 할 것은 <code>원인 X 결과</code>

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/15a30288-c2dd-460a-8e54-2adf1240afc0" width="50%"/>

- 원인과 결과를 분리하여 이를 <code>원인 + 결과</code>로 바꿀 수 있다!
  - 효과 추가 시 원인을, 원인 추가 시 효과를 고칠 필요가 없다.
  - 예: 이벤트 핸들러는 장바구니만 바꾸고, DOM을 갱신하는 코드는 DOM만 갱신하면 됨

> 🚨 **주의사항**

- 장바구니처럼 원인과 효과의 중심이 없다면 이처럼 분리하지 않도록 주의하자!
- 그런 경우 코드에 액션을 순서대로 표현하는 것이 명확할 수도 있다.

### 2️⃣ 여러 단계를 파이프라인으로 처리한다.

```
함수형 도구를 연결해 만든 파이프라인으로 데이터 변환 과정을 처리할 수 있었다.
반응형 아키텍처로도 이와 비슷하게 액션과 계산을 조합할 수 있다.
```

- 반응형 아키텍처에서 간단한 액션과 계산을 조합해 만든 복잡한 동작은 파이프라인과 같다.

  - 데이터가 파이프라인으로 들어가 각 단계에서 처리된다.
  - 파이프라인: 작은 액션 + 계산 = 하나의 액션

- 여러 단계로 발생하는 일은 파이프라인으로 처리하는 것이 좋다.

  - 각 단계에서 생성된 데이터를 다음 단계의 입력값으로 사용할 수 있다.

- 반응형 프레임워크로 파이프라인을 구현할 수 있다.

  - 예) JS ➡️ Promise로 액션과 계산을 조합해 파이프라인 구현하기
  - Promise는 단일값 전달이 가능하므로 파이프라인 단계 간 데이터 전달 가능

- 이벤트 스트림이 필요할 경우 <code>ReactiveX</code> 사용 가능

  - 스트림에 map, filter 사용 가능

- 외부 스트림 서비스로 파이프라인 구현 가능
  - Kafka, RabbitMQ
  - 반응형 아키텍처를 더 큰 범위에 적용할 수 있다.
  - 액션/계산 단위를 넘어 서비스 관점에서 분리할 수 있다.

> 🚨 **주의사항**

- 여러 단계가 있지만 데이터를 전달하지 않는다면 사용하지 않는 것이 좋다.
- 데이터를 전달하지 않으면 파이프라인이 아니고, 올바른 반응형 아키텍처가 될 수 없다.

### 3️⃣ 타임라인이 유연해진다.

```
순서를 표현하는 방법을 뒤집으면 타임라인이 유연해진다.
유연성으로 인해 예상치 못한 순서로 실행될 수도 있지만, 익숙해지면 더 짧은 타임라인을 만들 수 있다.
```

- 순서를 정의하는 방법을 뒤집어서 타임라인이 자연스럽게 작은 부분으로 분리된다.

  - 긴 타임라인 하나 ➡️ 공유하는 자원이 없는 짧은 타임라인 여러 개로 분리

- 공유하는 자원이 없으면 타임라인이 많아져도 문제가 없다.
  - <code>ValueCell</code>에서는 감시자 호출 시 값을 넘겨주므로 감시자 함수가 직접 장바구니 값을 읽지 않는다.
    - 장바구니 값을 전역 변수로 사용하지 않아도 된다.
  - <code>FormulaCell</code>에서도 현재 값을 호출 시 넘겨주므로 DOM 갱신 시 직접 값을 읽지 않는다.
    - DOM을 갱신하는 모든 곳에서 자신의 DOM만 갱신하면 된다.
  - 타임라인이 서로 다른 자원을 사용하므로 안전하다.

### 🚨 반응형 아키텍처, 어디서 사용하면 좋을까

- 고객에게 알림을 보낼 때 고객, 상황마다 서로 다른 방법으로 알려줘야 하는 경우

  - 여러 원인(알림 종류) + 여러 효과(알림 전달 방법)
  - 반응형 아키텍처를 **사용하기 좋은** 상황
  - 원인과 효과를 분리해 해야 할 일을 독립적으로 처리할 수 있다.

- 반복적으로 문서를 전송하는 직관적이고, 순차적인 단계로 구성된 시스템
  - 반응형 아키텍처에 **잘 맞지 않는** 상황
  - 순차적인 단계가 있고 항상 원인은 하나!
    - 원인과 효과의 중심이 없으므로 반응형 아키텍처에서 관리할 것이 없다.
  - 직관적인 순차적인 액션을 사용하는 것이 좋다.

## 🧅 어니언 아키텍처

- 서비스의 모든 단계에 사용
- 웹 서비스, 온도 조절 장치 등 현실 세계와 상호작용하기 위한 서비스 구조를 만든다.
- 함수형 사고 적용 시 자연스럽게 쓸 수 있다.
- 반응형 아키텍처와 함께 사용하면 반응형 아키텍처가 어니언 아키텍처 안에 들어가 있지만, 서로 의존하지는 않는다.
- 어니언 아키텍처는 fractal이다.
  - fractal: 일부 조각이 전체와 비슷한 구조
  - 액션의 모든 추상화 수준에서 찾을 수 있다.
  - 어니언 아키텍처를 소프트웨어 전체에 적용할 수도, 작은 부분에서 적용할 수도 있다.

> 어니언 아키텍처의 계층

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/7308657f-a058-404e-92b7-cb189f78dba3" width="50%"/>

#### 💫 인터렉션 계층

- 바깥 세상에 영향을 주거나 받는 액션

#### 💫 도메인 계층

- 비즈니스 규칙을 정의하는 계산

#### 💫 언어 계층

- 언어 유틸리티와 라이브러리

> 함수형 시스템이 잘 동작할 수 있는 중요한 규칙

1. 현실 세계와의 상호작용은 인터렉션 계층에서 해야 한다.
2. 계층에서 호출하는 방향은 중심 방향이다.
3. 계층은 외부에 어떤 계층이 있는지 모른다.

### 🚨 전통적인 계층형 아키텍처

> 웹 서버를 만들 때 사용하는 전형적인 계층

|     계층      |
| :-----------: |
| 웹 인터페이스 |
|    도메인     |
| 데이터베이스  |

#### 💫 웹 인터페이스 계층

- 웹 요청을 도메인으로 바꾸고 도메인을 웹 응답으로 바꾼다.

#### 💫 도메인 계층

- 애플리케이션 핵심 로직
- 도메인 개념에 DB 쿼리나 명령이 들어간다.

#### 💫 데이터베이스 계층

- 시간에 따라 바뀌는 정보를 저장한다.

<br/>

- 전통적 계층형 아키텍처는 DB를 기반으로 한다.

  - 도메인 계층은 DB 동작으로 만든다.
  - 웹 인터페이스는 웹 요청을 도메인 동작으로 변환한다.

- 문제가 있는 것은 아니지만, 이 구조는 함수형 스타일이 아니다.
  - DB 계층이 가장 아래 있다면 그 위의 모든 것이 액션이 된다.
  - 모든 것이 계층에 쌓여 있고 계산은 따로 관리되지 않다가 우연히 사용된다.

### 🤖 함수형 아키텍처

- 함수형 아키텍처에서는 도메인 계층이 DB 계층에 의존하지 않는다.
  - DB 동작은 값을 바꾸거나 DB에 접근하므로 액션
  - 액션과 계산을 구분하고, 라이브러리나 언어 기능과 계산을 구분한다.
- 함수형 개발에서는 액션에서 계산을 명확하게 분리하고 도메인 로직은 모두 계산으로 만든다.
  - DB를 도메인과 분리하는 것이 중요!
  - 가장 위의 액션에서 도메인 규칙과 DB를 조합한다.

### 📢 변경과 재사용이 쉬워야 한다!

```
👩‍🏫 어니언 아키텍처는 인터랙션 계층을 바꾸기 쉬우므로, 도메인 계층을 재사용하기 좋습니다!
```

- 어니언 아키텍처는 인터렉션 계층을 바꾸기 쉽다.

  - 인터렉션 계층은 가장 위에 있어 가장 바꾸기 쉽다.
  - 어니언 아키텍처는 DB나 API 호출과 같은 외부 서비스를 바꾸기 쉽다.

- 도메인 계층은 외부 서비스에 의존하지 않아 테스트하기 좋다.

  - 도메인이 DB나 웹 요청에 의존하지 않으므로 인터렉션 계층의 DB나 서비스 프로토콜을 쉽게 바꿀 수 있다.
  - 도메인 계층도 DB나 서비스 같은 것을 사용하지 않으므로 전부 계산으로 만들 수 있다.

- 어니언 아키텍처는 좋은 인프라보다 **좋은 도메인**을 강조한다.

> 좋은 도메인 만들기

- 전통적인 아키텍처

  - 도메인 규칙은 DB를 호출한다.
  - 계층은 순서대로 쌓여 있다.
  - 웹 요청은 핸들러가 처리한다. ➡️ 핸들러는 DB에 접속하고, 가장 높은 웹 계층에 결과를 리턴해 클라이언트에게 응답한다.
  - 장바구니 합계를 계산하는 도메인 규칙은 DB에서 합계를 가져와 처리한다.
  - 이때, 도메인은 DB에 접근하므로 **계산이 아니다**.

- 어니언 아키텍처
  - 웹 서버, 핸들러, DB는 인터렉션 계층에 속한다.
  - 장바구니 합계를 만드는 **계산**은 장바구니가 어디에서 왔는지 알지 못한다.
  - 핸들러가 DB에서 장바구니를 가져와 도메인에 전달하는 역할을 한다. ➡️ 계층 구조가 다르지만 같은 일을 할 수 있음
  - 인터렉션 계층에서 값을 가져오고 도메인 계층에서 합산을 한다.

> 🤔 도메인 규칙이 액션이 되어야 하는 경우는 없을까?

- 액션에서 계산을 빼내 액션과 계산 모두 간단해지고, 액션은 작은 로직을 갖는 하위 단계 액션이 된다.
  - 빼낸 도메인 계산과 액션을 상위 단계의 액션으로 조합할 수 있다.
- 하지만 어떤 경우 도메인이 액션이 되어야 하는 경우도 있다.

```
👩‍🏫 이때 아래의 두 규칙을 사용하여 도메인 규칙이 액션이 될지, 계산이 될지 고민해봅시다!
```

### 1️⃣ 도메인 규칙은 도메인 용어를 사용한다.

> 도메인 규칙[비즈니스 규칙]

- 프로그램의 핵심 로직
- 모든 로직이 도메인 규칙인 것은 아니다.
  - 비즈니스에 중요한 부분이라고 해서 모두 도메인 규칙인 것이 아니다!
- 도메인 규칙에 속하는지 인터렉션 계층에 속하는지 판단하려면 코드에서 사용하는 용어를 보면 된다.

  - 제품, 이미지, 가격, 할인 ➡️ 도메인 규칙 O
  - (새로운/이전)DB ➡️ 도메인 규칙 X

### 2️⃣ 가독성과 어울리는지 따져봐야 한다.

- 도메인을 계산으로 만드는 것이 항상 좋은 것은 아니다.
- 아래의 사항을 고려하여 계산보다 액션이 가독성이 좋지 않을지 따져봐야 한다.
  - 사용하는 언어
  - 레거시 코드와 코드 스타일
  - 사용하는 라이브러리
  - 개발자들의 습관

```
👩‍🏫 어니언 아키텍처가 가장 이상적인 모습이지만, 아래의 문제와 이상적인 다이어그램 사이의 균형을 잡는 것이 중요합니다.
```

> 코드의 가독성

- 함수형 코드가 아닌 코드가 더 명확한 경우가 있다.
- 명확해지는 정도가 함수형 스타일을 사용하지 않아야 하는 정도인지 파악한다.
- 도메인 계층을 계산으로 만들어 인터렉션 계층과 분리하되, 가독성 좋은 코드를 만들기 위해 노력해야 한다.

> 개발 속도

- 비즈니스적인 이유로 기능을 빨리 출시해야 하는 경우가 있다.
- 타협 후 나중에 아키텍처에 맞춰 코드를 정리할 준비를 하는 것이 좋다.
  - 계산 추출 ➡️ 함수형 도구로 코드 연결 ➡️ 타임라인 관리

> 시스템 성능

- 변경 가능한 데이터 구조는 불변 데이터 구조보다 빠르다.
- 성능 개선과 도메인을 계산으로 만드는 것은 분리하여 고려해야 한다.
  ➡️ 최적화는 인터렉션 계층에서 하고, 도메인 계층은 재사용 가능하게 만들기
