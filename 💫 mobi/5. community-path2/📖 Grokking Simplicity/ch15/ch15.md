# 💡 CH15. 타임라인 격리하기

### 🐛 use-case 다이어그램으로 비동기 버그 이해하기

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/6f41112d-670d-490b-ae4b-c018aef3ca2d" width="50%"/>

- use-case 다이어그램에서는 고객이 장바구니에 제품을 추가하고 다음 제품을 추가할 때까지 기다리는 상황을 가정한다.
- 따라서 시스템은 올바르게 동작한다.

```
🤔 고객이 기다리지 않고 다음 제품을 추가할 때는 어떻게 볼 수 있을까요?
```

### 🎞️ 타임라인 다이어그램

> 타임라인

- 시간에 따른 액션의 순서
- 액션을 순서대로 나열한 것
- 여러 개의 타임라인이 동시에 실행되기도 한다.

> 타임라인 다이어그램

- 시간에 따른 액션 순서를 시각적으로 표시한 것
- 다이어그램 옆으로 타임라인을 하나씩 추가하며 각 액션이 서로 어떻게 상호작용하고 간섭하는지 볼 수 있다.

### 🌟 타임라인 다이어그램의 기본 규칙

```js
function dinner(food) {
  cook(food);
  serve(food);
  eat(food);
}
```

### 🔎 액션 순서에 관한 두 가지 사실

### 📢 비동기 호출은 새로운 타임라인으로 그립니다!

```js
saveUserAjax(user, function () {
  setUserLoadingDOM(false);
});
setUserLoadingDOM(true);
saveDocumentAjax(document, function () {
  setDocLoadingDOM(false);
});
setDocLoadingDOM(true);
```

### 🔣 서로 다른 언어, 서로 다른 스레드 모델

### 🏗️ 한 단계씩 타임라인 만들기

```
👩‍🏫 여기서 우리는 타임라인 다이어그램을 통해 두 가지 사실을 알 수 있습니다.
1. 순서대로 실행되는 코드에도 두 가지 종류가 있습니다.
2. 동시에 실행되는 코드는 순서를 예측할 수 없다는 것을 알 수 있습니다.
```

### 🤖 순서대로 실행되는 코드 구분하기

### 👾 순서를 예측할 수 없는 동시에 실행되는 코드

### 💓 좋은 타임라인의 원칙

### 🪡 JS의 단일 스레드

### 🚥 JS의 비동기 큐

### 🧞 AJAX와 이벤트 큐

### ✂️ 타임라인 단순화하기

### 📖 완성된 타임라인 읽기

### 🛒 add-to-cart 타임라인 단순화하기

### 👥 타임라인을 나란히 보면 문제가 보인다!

### ⚠️ 자원을 공유하는 타임라인은 문제가 생길 수 있다!

### 📑 TL;DR: 타임라인 다이어그램 그리기

### 📢 비동기 호출의 원칙

```
🤠 비동기 호출에서 명시적인 호출을 위해 리턴값 대신 콜백을 사용할 수 있습니다!
```

> 비동기 함수에서 리턴값을 사용하지 못하는 이유
