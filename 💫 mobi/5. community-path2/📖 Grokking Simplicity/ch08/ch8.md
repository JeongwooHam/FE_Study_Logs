# 💡 CH8. 계층형 설계 (1)

## 🛠️ 계층형 설계

### ⚙️ 소프트웨어 설계

    코드를 만들고, 테스트하고, 유지보수하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것

### 🤔 계층형 설계란?

    - 소프트웨어를 계층으로 구성하는 기술
    - 각 계층의 함수는 바로 아래 계층에 있는 함수를 이용해 정의함

> 계층이란?

##### 🌟 계층을 잘 구분하려면, 구분하기 위한 다양한 변수를 찾고, 이를 어떻게 사용해야 하는지 알아야 함

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/d3e70be8-c5d6-47b2-9d9d-abd90c23a3b8" width="60%">

### 🏷️ 계층 설계의 단서가 될 입력

| 함수 본문                                                                                       |     | 계층 구조                                        |     | 함수 시그니처                                            |
| :---------------------------------------------------------------------------------------------- | :-: | :----------------------------------------------- | :-: | :------------------------------------------------------- |
| ● 길이 <br/> ● 복잡성 <br/> ● 구체화 단계 <br/> ● 함수 호출 <br/> ● 프로그래밍 언어의 기능 사용 |     | ● 화살표 길이 <br/> ● 응집도 <br/> ● 구체화 단계 |     | ● 함수명 <br/> ● 인자 이름 <br/> ● 인잣값 <br/> ● 리턴값 |

### 🔖 계층 설계의 단서가 될 출력

| 조직화                                                                       |     | 구현                                                           |     | 변경                                                                    |
| :--------------------------------------------------------------------------- | :-: | :------------------------------------------------------------- | :-: | :---------------------------------------------------------------------- |
| ● 새로운 함수를 어디에 놓을지 결정하기 <br/> ● 함수를 다른 곳으로 이동시키기 |     | ● 구현 바꾸기 <br/> ● 함수 추출하기 <br/> ● 데이터 구조 바꾸기 |     | ● 새 코드 작성할 곳 선택하기 <br/> ● 적절한 수준의 구체화 단계 결정하기 |

<br/>

## 🤖 계층형 설계의 4가지 패턴

#### ✏️ Pattern1. 직접 설계하기

    직접 구현한 함수를 읽고, 함수 시그니처가 나타내고 있는 문제를 적절한 구체화 수준에서 해결하기

#### ✏️ Pattern2. 추상화 벽

    중요한 세부 구현을 감추고 인터페이스를 제공함으로써, 추상화 단계만 생각할 수 있게 하여 고차원 사고를 가능케 함

#### ✏️ Pattern3. 작은 인터페이스

    시스템이 커질수록 비즈니스 개념을 나타내는 인터페이스는 작고 강력한 동작으로 구성해주는 것이 좋음
    다른 동작들 또한 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 함

#### ✏️ Pattern4. 편리한 계층

    그냥 계층을 추가하는 것이 아니라, 코드와 그 코드가 속한 추상화 계층이 작업 시 편리할지 고민하여 추가해야 함

<br/>

## ✏️ Pattern1. 직접 설계하기

### 🪡 설계 스프린트

> 고려할 사항

- 함수가 알아야 할 필요가 없는 구체적인 내용을 담고 있진 않은가?
  - 예: 마케팅 캠페인 관련 함수가 장바구니의 타입을 알아야 할까?
    - 장바구니 배열에 대한 반복문을 수행하는 과정에서 오프-바이-원 에러가 발생한다면?
    - 오프-바이-원: 배열 등을 반복해서 처리할 때 비교문을 잘못 선택해 의도치 않게 마지막 항목을 처리하지 못하거나 처리하는 오류

<br/>

- 코드에 있는 지식으로 함수가 해야 할 동작 정리하기
  - 필요한 동작을 나열하고, 구현된 것 체크해보기

<br/>

- 저수준의 코드(반복문)은 추출해야 할 가능성이 높음
  - 개선된 함수는 짧고 명확함
  - 비슷한 구체화 수준에서 작동하게 되므로 가독성이 좋음

### 📊 호출 그래프를 만들어 [함수 호출](https://github.com/JeongwooHam/FE_Study_Logs/blob/master/%F0%9F%92%AB%20mobi/5.%20community-path2/%F0%9F%93%96%20Grokking%20Simplicity/ch08/code/0.%20Pattern1.js)을 시각화하기

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/4a4eba5b-5661-446a-9f9f-a75b3ede35e8" width="40%">

- 수정 전 함수의 호출 그래프
- 위처럼, 서로 다른 추상화 단계에 있는 기능을 사용하면 직접 구현 패턴이 아님

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/81bea58c-c2ad-436d-b850-1853073aaee6" width="40%">

- 수정 후 함수의 호출 그래프
- 개선된 함수는 더 가까운 추상화 계층을 호출하므로, 직접 구현에 가까워짐
- 인자로 받는 장바구니가 함수인지 알 필요가 없어짐

> 호출 그래프를 그려야 하는 이유

- 계층이 많을 때, 호출 그래프를 통해 시스템 계층이 어떻게 구성되어 있는지 확인 가능
- 복잡한 계층 정보는 단순히 코드를 작게 쪼개는 것만으로는 확인하기 어려움

<br/>

> 함수 이름은 함수가 어느 곳에 위치할지 결정하기 위한 정보로 쓸 수 있다!

- 🤔 [removeItems](https://github.com/JeongwooHam/FE_Study_Logs/blob/master/%F0%9F%92%AB%20mobi/5.%20community-path2/%F0%9F%93%96%20Grokking%20Simplicity/ch08/code/1.%20Extracting%20Loops_1.js)라는 함수는 호출 그래프의 어느 계층에 위치해야 할까?

  1. ⬇️ 가장 높은 계층보다는 하위에 있어야 함
     - 마케팅과 관련이 없는 일반적인 동작에 관한 이름
     - 마케팅 캠페인 함수나, 사용자 인터페이스와 같은 다른 함수에서 호출 가능
     - 화살표가 아래쪽을 향해야 한다는 규칙!

    <br/>
    
    2. ➡️ 가장 낮은 계층에 함께 위치할 수 있음
        - 장바구니와 제품이 가장 낮은 계층에 위치함
        - remove_items 함수도 장바구니를 다루므로 적절한 위치
        - 가장 낮은 계층의 함수들에서 remove_items 함수를 호출할 일은 없으므로 더 아래 계층으로 내려갈 필요는 없음

    <br/>
    
    3. ⬆️ 가장 높은 계층과 가장 낮은 계층 사이에 새 계층을 생성할 필요는 없음
        - 호출하는 함수나 언어 기능이 동일하여 그래프 상에서 같은 박스를 가리키게 됨
        - remove_items 함수가 가장 낮은 계층에 있는 함수와 비슷한 점이 있으므로 가장 낮은 계층에 위치할 수 있음

### 📌 같은 계층에 있는 함수는 같은 목적을 가져야 한다!

    - 계층이 서로 구분되는 목적이 있다면, 함수가 위치할 계층 선택 시 좋은 지표가 됨
    - 계층의 목적은 각 계층에 있는 함수의 목적과 같음
    - 함수가 호출하는 것을 그대로 표현한 다이어그램을 통해 함수를 어떤 계층에 놓을지 바로 파악 가능
    - 각 계층의 추상화 수준은 다름
    - 함수를 읽거나 고칠 때 낮은 수준의 구체적인 내용은 고려할 필요 없음
    - 예: 장바구니 비즈니스 규칙에 포함되는 함수에서 장바구니가 배열인지 여부는 고려할 필요 없음

|     각 계층의 목적     |                           예시                            |
| :--------------------: | :-------------------------------------------------------: |
| 장바구니 비즈니스 규칙 | 넥타이 구매 시 넥타이 클립 증정하기, 장바구니 세금 구하기 |
| 일반적인 비즈니스 규칙 |                       세금 계산하기                       |
|   장바구니 기본 동작   |   장바구니에 담겨있는지 확인하기, 장바구니 총액 구하기    |
| 제품에 대한 기본 동작  |              아이템 생성하기, 가격 설정하기               |
|     copy-on-write      |   아이템을 배열에 추가하기, 아이템을 배열에서 제거하기    |
|      JS 언어 기능      |                       slice, 반복문                       |

<br/>

## 🔎 3단계 줌 레벨로 다이어그램 톺아보기

: 다이어그램에 너무 많은 정보가 있어 문제 발생 부분을 찾기 어려울 때, 세 가지 영역을 살펴봄으로써 파악 가능

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/36c43bd6-ac69-470c-828d-fa9cf4b05a51" width="60%">

### 🌟 1. 전역 줌 레벨 (계층 사이 상호 관계)

    - 기본 줌 레벨
    - 계층 사이 상호 관계를 포함해 모든 문제 영역을 살펴볼 수 있음

⬇️ **계층 확대**

### 🌟 2. 계층 줌 레벨 (특정 계층의 구현)

    - 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨
    - 각 계층이 어떻게 구현되어 있는지 알 수 있음

⬇️ **함수 확대**

### 🌟 3. 함수 줌 레벨 (특정 함수의 구현)

    - 함수 하나와 바로 아래 연결된 함수들을 볼 수 있음
    - 함수 구현의 문제를 찾을 수 있음

### 📌 계층 줌 레벨로 함수가 가리키는 화살표를 계층 간에 비교할 수 있다!

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/f7a7b986-1345-4163-a781-8326816687da" width="60%">

- 가격 수정 함수는 짧은 화살표와 긴 화살표를 모두 가지고 있음
- 이처럼 다이어그램이 복잡한 이유는 코드가 정돈되어 있지 않기 때문
- 직접 구현 패턴 사용 시 모든 화살표가 같은 길이를 가져야 함
  - 위 다이어그램에서는 한 계층 길이, 세 계층 길이 등 화살표의 길이가 제각각
  - 다양한 계층을 넘나드는 것은 같은 구체화 수준이 아님을 의미

### 📌 함수 줌 레벨로 함수 하나가 가진 화살표를 비교할 수 있다!

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/771e8871-2100-42df-9fa9-ab27ccf76648" width="50%">

- 함수가 서로 다른 계층의 동작을 사용하고 있음 ➡️ 직접 구현 패턴과 맞지 않음
- 🤔 어떻게 하면 모두 같은 길이의 화살표를 갖도록 할 수 있을까?

> 중간에 함수 두기

<img src = "https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/f561bc18-2aa4-4fe7-844e-75c54f28b923" width="50%">

- 반복문과 배열의 인덱스 참조를 담당하는 함수를 새로 생성
- 이 함수를 구현하기 위해서는 반복문을 코드에서 빼내야 함
  <br/> ➡️ 다이어그램은 무엇을 새로 구현해야 할지 보여줌

<br/>

## 🐳 직접 구현 패턴 리뷰

#### 🌟 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결함

    - 코드가 서로 다른 구체화 단계에 있다면 가독성이 좋지 않음
    - 코드를 읽을 때 구체화 단계가 다르면 이해하기 어려움
    - 직접 구현 시 코드를 읽기 위해 알아야 하는 구체화 단계의 범위를 줄일 수 있음

#### 🌟 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와줌

    코드에 있는 다양한 단서를 통해 구체화 수준에 집중함으로써 설계 감각을 키우고, 코드를 필요에 맞게 수정 가능

#### 🌟 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여줌

    - 코드에 내재된 설계 개선에 대한 단서들을 큰 그림으로 한번에 보기에는 너무 방대함
    - 호출 그래프를 통해 함수가 서로 어떻게 연결되어 있는지 볼 수 있음
    - 함수 시그니처와 본문, 호출 그래프와 같은 단서로 직접 코드 패턴 적용 가능

#### 🌟 함수를 추출하면 더 일반적인 함수로 만들 수 있음

    - 함수가 더 구체적인 내용을 다루지 않도록 일반적인 함수로 빼냄으로써 직접 구현 패턴 적용 가능
    - 일반적인 함수는 구체적인 내용을 하나만 다루므로 테스트에 용이
    - 명확한 코드, 알맞은 이름을 가지고 있어 가독성이 좋음

#### 🌟 일반적인 함수가 많을수록 재사용하기 좋음

    - 함수로 빼내면 재사용에 좋음
    - 단순히 '중복 코드'를 제거하는 것과는 다름!
    - 구현을 명확하게 하기 위해 일반적인 함수를 빼내는 것
      ➡️ 구체적인 함수보다 더 많은 곳에서 사용 가능
      ➡️ 사용할 곳을 따로 찾지 않아도 재사용할 수 있는 부분 발견 가능

#### 🌟 복잡성을 감추지 않음

    - 도우미 함수를 생성하여 명확하지 않은 코드를 감추고, 직접 구현 패턴을 적용한 코드처럼 보이게 만들 수 있음
    - 하지만 이는 계층형 설계가 아님!
    - 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 함
    - 따라서, 복잡한 코드를 같은 계층으로 옮기면 안 되고,
      더 낮은 구체화 수준을 가진 일반적인 함수를 만들어 직접 구현 패턴을 적용해야 함
