<p align="center"><img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/4b3642f9-ddfa-4651-9d63-35541b69a111" width="60%"/></p>

## 🥏 다시 돌아온 SSR!

- 이전에 Next.js를 사용하게 된 이유에서도 정리했지만,
- React, Angular, Vue와 같은 SPA 프레임워크들이 사용하던 CSR 방식에 문제점이 발견되기 시작했다.

> CSR의 문제점

1.  SEO에 적합하지 못하다.
2.  성능 문제
3.  사용자가 첫 화면을 보기까지의 로딩이 오래 걸린다.

> SSR의 재등장

- SSR에서는, 웹 사이트 접속 시 서버에서 필요한 데이터를 모두 가져와 HTML 파일과 이를 동적으로 제어할 수 있는 소스 코드를 생성하여 클라이언트에게 보낸다.
- 클라이언트는 잘 만들어진 HTML 문서를 사용자에게 바로 보여주게 된다.
  - 페이지 로딩이 빨라진다.
  - CSR과 달리 모든 컨텐츠가 HTML에 담겨 있어 효율적인 SEO가 가능해졌다.

> 그러나 SSR의 문제점!

1. Blinking Issue
2. 서버 과부하
3. 웹이 제대로 반응하지 않을 수 있다.

<br/>

    🗣️ 웹이 제대로 반응하지 않는다는 것은 무슨 의미인가요?

위의 질문에 대해 제대로 대답하기 위해서는 TTV, TTI라는 개념을 먼저 파악해야 한다.

## TTV와 TTI

### 🖥️ TTV

- Time To View
- 사용자가 웹 사이트를 볼 수 있는 시간

### 🖱️ TTI

- Time To Interact
- 사용자가 웹 사이트와 상호작용(클릭 등)을 할 수 있는 시간

### 🌟 CSR의 경우

- 사용자가 사이트 접속 시, 서버는 비어있는 HTML 문서를 넘겨준다.
- 클라이언트는 HTML에 링크된 JS 파일을 서버에 요청하고, 서버는 해당 JS 파일을 클라이언트에게 전송한다.
- 클라이언트가 JS 파일을 받은 후에야 브라우저 화면에 웹 페이지가 뜨므로, 사용자가 웹 페이지와 바로 상호작용할 수 있다.
- **CSR에서는 <code>TTV === TTI</code>**

### 🚨 SSR의 경우

- 사용자가 사이트 접속 시, 서버는 이미 만들어진 HTML 문서를 클라이언트에게 넘겨준다.
- 이 때문에 사용자는 화면을 바로 볼 수 있다.
- 하지만 아직 JS 파일은 받지 못한 상태이므로, 바로 상호작용이 불가능하다.
- **SSR에서는 <code>TTV !== TTI</code>** (시간차가 존재한다.)

- 문제점
  - CSR의 경우 처음 로딩 속도를 줄이기 위해 JS 파일을 분할하여 필요한 정보만 보낼 수 있는 방법이 필요하다.
  - SSR의 경우 TTV와 TTI의 시간차를 줄이기 위한 방법이 필요하다.

<br/>

    📢 이를 해결하기 위해 등장한 SSG!

## SSG

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/292d03be-2fbf-4154-957a-b1497d3a4776" width="50%"/>

- 미리 서버에 HTML 파일을 만들어두고, 이를 사용자에게 보여준다.
- 사용자와의 상호작용 시 데이터가 변하지 않을 페이지는 미리 서버에서 HTML 파일을 만들어두고, 클라이언트의 요청이 있을 때마다 이 파일을 주는 방식
- CSR, SSR보다 렌더링 속도가 훨씬 빠르다.

### [CSR 🤼 SSR]() 🤼 SSG

| 분류 |        Meaning         |                   방식                    |
| :--: | :--------------------: | :---------------------------------------: |
| CSR  | Client-Side-Rendering  |     화면을 클라이언트단에서 바꾸는 것     |
| SSR  | Server-Side-Rendering  |      화면을 서버단에서 전송해주는 것      |
| SSG  | Server-Side-Generation | 화면을 서버에서 미리 만들어 전송해주는 것 |

> 🧐 CSR, 언제 써야 할까?

- 네트워크가 빠를 때
- 서버의 성능이 좋지 않을 때
- 사용자에게 보여줘야 하는 데이터의 양이 많을 때 (로딩 화면을 보여줄 수 있음)
- 메인 Script 로직이 가벼울 때
- SEO가 중요하지 않을 때
- 웹 애플리케이션에 사용자와 상호작용하는 부분이 많을 때 (UX가 중요한 경우)

> 🧐 SSR, 언제 써야 할까?

- 네트워크가 느릴 때
- 표시된 데이터가 항상 최신 데이터일 때
- 자주 변경될 가능성이 있는 사용자별 데이터 or 동적 데이터일 때
- SEO가 중요할 때
- 최초 로딩이 빠른 페이지가 필요할 때
- 메인 Script 로직이 무겁고 로딩이 오래 걸릴 때
- 웹 사이트의 상호작용이 적을 때

> 🧐 SSG, 언제 써야 할까?

- 정적인 정보를 항상 보여주는 페이지일 때 (예: 블로그)
- 상호작용을 위한 데이터가 존재하지 않을 때

## ISR

## Next.js 12에서의 SSR, SSG, ISR

### getServerSideProps( )

### getStaticProps( )

### getStaticProps( ), revalidate

## Next.js 13에서는 어떻게 바뀌었을까?

### fetch

### cache

## 🔎 References

<details>
<summary>참고 자료 모음</summary>
<div markdown="1">

- [[Next.js] CSR vs SSR](https://velog.io/@wooseok123/Next.js-CSR-vs-SSR)
- [[FE][Next JS] 웹 렌더링의 과거와 현재, 그리고 미래 ⏱ / 4️⃣ - Static Site Generation과 ISR (Incremental Static Regeneration)](https://programming119.tistory.com/278)
- [[FE] SSR(Server-Side-Rendering) 그리고 SSG(Static-Site-Generation) (feat. NEXT를 중심으로)](https://velog.io/@longroadhome/FE-SSRServer-Side-Rendering-%EA%B7%B8%EB%A6%AC%EA%B3%A0-SSGStatic-Site-Generation-feat.-NEXT%EB%A5%BC-%EC%A4%91%EC%8B%AC%EC%9C%BC%EB%A1%9C)
- [[Next js] SSR, SSG, ISR 이해하기](https://velog.io/@bbaa3218/Next-js-SSG-SSR-ISR)
- [[Next.js] Next.js 13 - Data Fetching, Server Components](https://ahnanne.tistory.com/92)
- [[Next.js] Next.js의 프리 렌더링(pre-rendering) 옵션 3가지 / SSG, SSR, ISR](https://ahnanne.tistory.com/75)
- [SSR, CSR, SSG, ISR 이해해보기..](https://xionwcfm.tistory.com/291)
- [Nextjs data Fetching 이해하기 (CSR, SSR, SSG, ISR)](https://www.philly.im/blog/grokking-data-fetching-in-nextjs)
- [[Next.js] SSR, SSG, ISR 구성하기](https://unho94.tistory.com/213)
- [Understanding the SSR, SSG, and ISR in Next.js 13](https://medium.com/@fahdkassim/understanding-the-ssr-ssg-and-isr-in-next-js-13-33bd32e1580e)
- [Next.js 13에서 SSG와 ISR 적용하기](https://mycodings.fly.dev/blog/2022-11-16-nextjs-13-how-to-ssg-isr-and-not-found)

</div>
</details>
