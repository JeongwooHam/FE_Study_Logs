# 💡 CH12. 함수형 반복

## 📬 함수를 전달하는 세 가지 방법

### 🌌 전역으로 정의하기

- 함수를 전역으로 정의하고 이름을 붙이는 방법으로, 함수 정의 시 가장 많이 쓰이는 방법
- 붙인 이름으로 프로그램 어디서나 사용 가능

```jsx
// 프로그램 한 곳에서 이름 붙여 정의
function greet(name) {
  return "Hello, " + name;
}
// 어디서나 이름으로 함수 참조가 가능함. 인자로 전달 가능
let friendGreetings = map(friendsNames, greet);
```

### 🌍 지역적으로 정의하기

- 함수를 지역 범위 안에서 정의하고 이름을 붙이는 것
- 기명함수이지만 범위 밖에서는 사용할 수 없음
- 지역적으로 쓰고 싶지만 이름이 필요할 때 유용

```jsx
// 범위: greetEverybody 함수 내부
function greetEverybody(friends) {
  let greeting;
  if (language === "English") greeting = "Hello, ";
  else greeting = "Salut, ";
  // 함수 내부에서 이름을 붙여 함수 정의
  let greet = function (name) {
    return greeting + name;
  };
  // 같은 범위에 있다면 이름으로 함수 참조 가능
  return map(friends, greet);
}
```

### 🏡 인라인으로 정의하기

- 함수를 사용하는 곳에서 바로 정의하는 것
- 문맥에서 짧게 한 번만 쓰는 함수에 사용하면 좋음

> 인라인

- 쓰는 곳에서 바로 정의하는 함수
- 인자를 넘기는 곳에서 바로 정의되는 경우

> 익명함수

- 이름이 없는 함수
- 보통 필요한 곳에서 인라인으로 정의

```jsx
// 함수를 사용하는 곳에서 정의
let friendGreetings = map(friendsNames, (name) => {
  return "Hello, " + name;
});
```

## 🗺️ 함수형 도구 **map()**

- 어떤 배열의 모든 항목에 함수를 적용해 새로운 배열로 바꿈
- X(어떤 값의 집합) 값이 있는 배열을 Y(또 다른 값의 집합) 값이 있는 배열로 변환하는 역할
- 값 하나를 바꾸는 함수를 배열 전체를 바꾸는 데 사용할 수 있음

```jsx
// 1. 배열과 함수를 인자로 받는다.
function map(array, f) {
  // 2. 빈 배열을 생성한다.
  const newArray = [];
  // 3. 원래 배열 항목으로 새로운 항목을 만들기 위해 f() 함수를 호출한다.
  // 4. 새로운 배열에 원래 배열 항목에 해당하는 새로운 항목을 추가한다.
  forEach(array, function (element) {
    newArray.push(f(element));
  });
  // 5. 새로운 배열을 리턴한다.
  return newArray;
}
```

- map()에 계산을 넘기면 map()을 사용하는 코드도 계산, 액션을 넘기면 map()을 사용하는 코드는 액션이 됨
- 전달하는 함수는 익명함수를 사용해 인라인으로 정의함
- 주어진 배열과 같은 길이의 배열을 리턴하게 됨
- 단순하지만 리턴값인 배열에 들어있는 항목을 확인하지 않으므로 주의해서 사용할 것!

### 🔎 QnA

> 🤔 map() 함수에 빈 배열을 넘기면?

<code>map([], func)</code>
<br/>

    🤖 빈 배열을 리턴합니다.

> 🤔 map() 함수에 인자를 그대로 리턴하는 함수를 넘기면?

<code>map(array, (x) => x)</code>
<br/>

    🤖 얕은 복사가 된 배열을 리턴합니다.

## ⚗️ 함수형 도구 **filter()**

- 어떤 배열의 하위 집합을 선택해 새로운 배열로 만듦
- 배열에서 일부 항목을 선택하는 함수
- 새로운 배열에 담을 항목과 건너뛸 항목을 결정할 수 있음
- 항목은 원래와 같은 순서와 값을 유지하지만 선택된 값만 리턴하므로 개수는 적어질 수 있음

```jsx
// 1. 배열과 함수를 받는다.
function filter(array, f) {
  // 2. 빈 배열을 만든다.
  const newArray = [];
  forEach(array, function (element) {
    // 3. f()를 호출해 항목을 결과 배열에 넣을지 확인한다.
    // 4. 조건에 맞으면 원래 항목을 결과 배열에 넣는다.
    if (f(element)) newArray.push(element);
  });
  // 5. 결과 배열을 리턴한다.
  return newArray;
}
```

> 술어

    - 불리언 값을 리턴하는 함수
    - filter()에서는 항목 선택을 위해 항목이 X인 배열을 받아 불리언 타입을 리턴하는 함수를 전달해야 함

### 🔎 QnA

> 🤔 filter() 함수에 빈 배열을 넘기면?

<code>filter([], func)</code>
<br/>

    🤖 빈 배열을 리턴합니다.

> 🤔 filter() 함수에 항상 true를 리턴하는 함수를 넘기면?

<code>filter(array, (\_x) => true)</code>
<br/>

    🤖 얕은 복사가 된 배열을 리턴합니다.

> 🤔 filter() 함수에 항상 false를 리턴하는 함수를 넘기면?

<code>filter(array, (\_x) => false)</code>
<br/>

    🤖 빈 배열을 리턴합니다.

## 🛝 함수형 도구 **reduce()**

- 어떤 배열의 항목을 조합해 최종 값을 만듦
- 배열을 순회하면서 값을 누적해가는 함수
- **_누적한다_** 는 것은 추상적인 개념으로, 실제로는 여러 형태가 될 수 있음
  - 더하기, 해시 맵이나 문자열 합치기 등
  - 전달하는 함수를 통해 누적하는 방법을 결정할 수 있음
- 누적하고 있는 현재 값과 반복하고 있는 현재 배열의 항목을 인자로 받아 새로운 누적값을 리턴함
- 다른 언어의 <code>fold()</code> 함수와 비슷한 기능

```jsx
// 1. 배열과 초깃값, 누적 함수를 받아옴
function reduce(array, init, f) {
  // 2. 누적 값 초기화
  let accum = init;
  // 3. 누적값을 계산하기 위해 현재 값과 배열 항목으로 f() 함수를 부름
  forEach(array, function (element) {
    accum = f(accum, element);
  });
  // 누적된 값 리턴
  return accum;
}
```

> reduce() 함수의 인자 순서

1. 배열
2. 나머지 인자 (초기값)
3. 콜백

> reduce()의 초기값을 결정하는 방법

1. 계산이 어떤 값에서 시작되는가?
2. 배열이 비어 있다면 어떤 값을 리턴할 것인가?
3. 비즈니스 규칙이 있는가?

### ⚒️ reduce()로 할 수 있는 것들

> 실행 취소 / 실행 복귀

- 리스트 형태의 사용자 입력에 reduce()를 적용한 것이 현재 상태
- 리스트의 마지막 사용자 입력을 없앰으로써 실행 취소 구현 가능

> 테스트 시 사용자 입력 재실행

- 시스템의 처음 상태가 초기값, 사용자 입력이 순서대로 리스트에 있을 때
- reduce()로 모든 값을 담아 현재 상태를 만들고 재실행시킬 수 있음

> 시간 여행 디버깅

- 변경 사항을 특정 시점으로 되돌릴 수 있음
- 에러가 발생한 경우 특정 시점 상태의 값을 보관 후 문제를 수정한 뒤 새로운 코드로 다시 실행해 볼 수 있음

> 특정 시점의 시스템 상태 파악

- 과거에 어떤 일이 있었는지를 기록함으로써 일이 어떤 과정을 통해 발생했는지 알 수 있음
- 예: 특정 일자의 지출 내역 추적

### 🔎 QnA

> 🤔 reduce() 함수에 빈 배열을 넘기면?

<code>reduce([], initialVal, func)</code>
<br/>

    🤖 initialVal(초기값)을 리턴합니다.
