# 💡 CH9. 계층형 설계 (2)

## ✏️ Pattern2. 추상화 벽

### 🙈 추상화 벽으로 구현 감추기

> 추상화 벽

- 🤔 어떤 것을 신경쓰지 않아도 되지?
- 세부 구현을 감춘 함수로 이루어진 계층
- 추상화 벽에 있는 함수 사용 시 구현(데이터 구조)을 전혀 몰라도 함수 사용 가능
- 계층 구조에서 어떤 계층에 있는 함수들이 공통 로직을 신경쓰지 않아도 되는 경우

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/56c9f25a-4afa-44f7-96e6-e94b41b88051" width="70%"/>

- 추상화 벽 위의 함수는 마케팅에서 독립적으로 사용할 수 있는 로직
- 추상화 벽 아래의 함수는 개발에서 독립적으로 사용할 수 있는 로직
- 🌟 벽을 가로지르는 화살표가 없어야 함!
  - 있다면, 추상화 벽에 새로운 함수를 만듦으로써 없애주어야 함

### 🪞 세부적인 것을 감추는 것은 대칭적!

- 각 팀은 본인이 담당하는 부분에 대한 로직만 알면 되므로 대칭적임
- 개발하는 팀과 사용하는 팀은 각자의 독립적인 업무만 하면 됨
- 예: API를 개발한 팀은 어디서 어떻게 사용되는지는 신경쓰지 않을 수 있음

### 👾 추상화 벽, 언제 사용하면 좋을까?

> 💫 쉽게 구현을 바꾸고 싶을 때

- 최선의 구현을 확신하기 어려워 간접 구현이 필요한 경우
  - 프로토타이핑: 시제품이 나오기 전의 제품의 원형
  - 서버에서 데이터를 받아 처리해야 하지만 아직 준비가 되지 않아 임시 데이터를 줘야 하는 경우
- 🚨 그럼에도, 가능성 없는 미래 때문에 불필요한 코드를 작성하게 되지 않도록 주의할 것!

> 💫 코드를 읽고 쓰기 쉽게 만들고 싶을 때

- 사소한 값 하나로 버그가 생기는 것을 방지해 세부적인 것에 신경을 덜 쓸 수 있음
- 코드 개발의 생산성 증가!

> 💫 팀 간에 조율해야 할 것을 줄이고 싶을 때

- 각 팀에 관한 구체적인 내용을 신경쓰지 않고도 코드 수정 가능
- 개발의 속도 증가!

> 💫 주어진 문제에 집중하고 싶을 때

- 해결하려는 문제의 구체적인 부분을 신경쓰지 않게 되어 실수를 줄일 수 있음

<br/>

## ✏️ Pattern3. 작은 인터페이스

### 🔎 작은 인터페이스 패턴

- 새로운 코드를 추가할 위치에 관한 것
- 인터페이스: 추상화 벽에 만든 함수
  - 이를 통해 어떤 값의 집합에 접근하거나 값을 조작할 수 있음
  - 완전한 추상화 벽과 최소한의 인터페이스 사이에서 유연한 조율 필요
- 인터페이스를 최소화하여 하위 계층에 불필요한 기능이 커지는 것을 막을 수 있음
- 새로 기능을 만들 때 하위 계층을 고치지 않고도 상위 계층에서 문제를 해결할 수 있게 함
- 추상화 벽 뿐만 아니라 모든 계층에서 적용 가능!

### 👾 추상화 벽, 왜 작게 만들어져야 할까?

    1. 추상화 벽에 코드가 많을수록 구현 변경 시 수정할 사항이 많아짐
    2. 추상화 벽에 있는 코드는 낮은 수준의 코드이므로 더 많은 버그 발생 가능
    3. 낮은 수준의 코드는 이해하기 더 어려움
    4. 추상화 벽에 코드가 많을수록 팀 간 조율해야 할 것이 많아짐
    5. 추상화 벽에 인터페이스가 많으면 알아야 할 것이 많아 사용에 어려움이 생김

### 👾 추상화 벽, 어떻게 작게 만들 수 있을까?

    - 가능한 현재 계층에 있는 함수로 구현하기
    - 함수의 목적을 파악하고, 어떤 계층에 구현하는 것이 적합할지 고려하기
    - 필요한 함수만 가지고 있는 이상적인 계층 만들기
    - 계층이 가진 함수는 완전하고, 적고, 시간이 지나도 바뀌지 않아야 함
    - 호출 그래프 하위 계층에 작고 강력한 동작을 만들기
    - 함수의 목적에 맞는 계층이 어디인지 파악하는 것이 가장 중요!

<br/>

## ✏️ Pattern4. 편리한 계층

- 호출 그래프를 통해 재사용이 쉽고, 테스트 및 유지보수에 용이한 코드 만들기
- 어떤 계층에 코드를 추가해도 이러한 장점을 유지할 수 있어야 함

### 🤔 그래프를 통해 알 수 있는 코드에 대한 정보에는 무엇이 있을까?

- 호출 그래프는 함수가 어떤 함수를 호출하는지 보여줌

    <img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/6dcbc779-15a1-4a7d-9fad-29db974c5876" width="30%"/>

> 기능적 요구사항

- 소프트웨어가 정확히 해야 하는 일
- 예: 세금에 대해 계산해서 올바른 결과가 나오게 하기

> 비기능적 요구사항

- 유지보수성
  - 유지보수하기 어렵지 않은지
  - 요구 사항 변경 시 가장 쉽게 고칠 수 있는 코드는 어떤 코드인가?
- 테스트성
  - 테스트를 어떻게 할 것인지
  - 어떤 것을 테스트하는 것이 가장 중요한가?
- 재사용성
  - 재사용을 잘 할 수 있는지
  - 어떤 함수가 재사용하기 좋은가?
- 소프트웨어 설계를 하는 중요한 이유
- 호출 그래프에서 함수 이름을 없애면 볼 수 있는 **구조**는 **비기능적** 요구사항을 보여줌

### ⚒️ 유지보수성

> 그래프의 가장 위에 있는 코드가 고치기 가장 쉽다!

- 호출 그래프로 코드를 어디에 두면 좋은지 알 수 있음
- 코드를 적절한 위치에 두면 유지보수 비용을 많이 줄일 수 있음
- 함수는 그래프 위에서 멀어질수록 더 고치기 어려움
  - 가장 아래에 있는 코드는 위에 많은 코드가 있으므로 고치기 힘듦
    - 시간이 지나도 변하지 않는 코드는 가장 아래 계층에 있어야 함
    - 한번 만들어두면 바꿀 일이 없는 경우
    - 예: copy-on-write 함수
  - 가장 위에 있는 코드는 어디에서도 호출하지 않으므로 수정이 쉬움
- 자주 바뀌는 코드는 그래프 위에 있을수록 업무가 쉬워짐
  - 하지만 바뀌는 것이 많은 가장 높은 곳은 적게 유지하는 것이 좋음

<br/>

    - 위로 연결된 것이 적은 함수가 바꾸기 쉽다.
    - 자주 바뀌는 코드는 가능한 위쪽에 있어야 한다.

### ⚒️ 테스트성

> 아래에 있는 코드는 테스트가 중요하다!

- 모든 코드를 테스트하는 것은 비현실적이르모, 장기적으로 좋은 결과를 위해 어떤 것을 테스트할 지 선택해야 함
- 가장 위에 있는 함수를 테스트하면 많은 코드를 확인할 수 있음
- 하지만 테스트 할 수 있는 시간이 많지 않다면, 가장 아래의 함수들을 테스트하는 것이 좋음
  - 많은 코드가 가장 아래에서 잘 동작하는 코드에 의존함
  - 가장 위에 있는 코드가 더 자주 바뀌므로 테스트해서 얻는 것이 적음
  - 가장 아래에 있는 코드가 전체 코드에 더 많은 영향을 줌
  - 가장 아래의 코드에 대한 테스트 코드는 오래 가므로, 테스트해서 얻는 것이 많음
- 즉, 하위 계층 코드를 테스트할 수록 얻은 것이 더 오래 감

<br/>

    - 위쪽으로 많이 연결된 함수를 테스트하는 것이 더 가치 있다.
    - 아래쪽에 있는 함수를 테스트하는 것이 위쪽에 있는 테스트하는 것보다 가치 있다.

### ⚒️ 재사용성

> 아래에 있는 코드가 재사용하기 더 좋다!

- 코드를 재사용하면 코드를 다시 만들지 않아도 되므로, 여러 번 고치거나 테스트하지 않아도 됨
- 코드 재사용 시 시간과 비용을 줄일 수 있음
- 낮은 계층을 함수 추출 시 재사용할 가능성 증가!
  - 아래쪽을 가리키는 화살표가 많으면 재사용하기 어려움
  - 표준 라이브러리를 부르는 곳까지 그래프를 아래로 확장할 수 있음
  - 표준 라이브러리는 어디서나 쓸 수 있으므로 가장 아래의 코드가 재사용하기 더 좋음

<br/>

    - 아래쪽에 있는 함수가 적을수록 더 재사용하기 좋다.
    - 낮은 수준의 단계로 함수를 빼내면 재사용성이 더 높아진다.
