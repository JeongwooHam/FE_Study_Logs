# 💡 CH15. 타임라인 격리하기

## 📑 TL;DR: 타임라인 다이어그램 그리기

### 1️⃣ 액션 확인하기

- 모든 액션은 타임라인에 표시되어야 한다.
- 변수를 읽고 쓰는 것처럼 하나의 액션처럼 보이지만 복합적인 액션도 있으므로 주의깊게 봐야 한다.

### 2️⃣ 액션 그리기

> 💡 순서대로 실행되는 액션

- 하나가 끝나고 다음 액션이 시작한다.
- 같은 타임라인에 표시한다.
- 문법에 있을 수도 있다.
  - 예: 함수의 인자가 왼쪽에서 오른쪽으로 평가됨

> 💡 동시에 실행되는 액션

- 동시에 실행되거나 왼쪽 먼저 또는 오른쪽 먼저 실행된다.
  - 예: 비동기 콜백, 멀티 프로세스, 멀티 스레드, 여러 장치
- 분리된 타임라인으로 표시한다.
- 모든 액션을 그린 후 실행 순서를 제한하기 위해 점선을 사용할 수 있다.

### 3️⃣ 타임라인 단순화하기

- 순서가 섞이지 않는 두 액션은 하나의 박스로 합친다.
- 타임라인 끝에서 새로운 타임라인이 하나만 생기면 하나로 합친다.
- 순서에 제약이 있는 경우 점선을 추가한다.

### 4️⃣ 타임라인 읽기

- 일반적으로 서로 다른 타임라인에 있는 액션은 동시에/왼쪽 먼저/오른쪽 먼저 실행될 수 있다.
- 이때 실행 순서를 예측하는 것은 불가능하거나 잘못된 결과를 가져올 수 있으므로 주의하자!

### 🐛 use-case 다이어그램으로 비동기 버그 이해하기

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/6f41112d-670d-490b-ae4b-c018aef3ca2d" width="50%"/>

- use-case 다이어그램에서는 고객이 장바구니에 제품을 추가하고 다음 제품을 추가할 때까지 기다리는 상황을 가정한다.
- 따라서 시스템은 올바르게 동작한다.

```
🤔 고객이 기다리지 않고 다음 제품을 추가할 때는 어떻게 볼 수 있을까요?
```

### 🎞️ 타임라인 다이어그램

> 타임라인

- 시간에 따른 액션의 순서
- 액션을 순서대로 나열한 것
- 여러 개의 타임라인이 동시에 실행되기도 한다.

> 타임라인 다이어그램

- 시간에 따른 액션 순서를 시각적으로 표시한 것
- 다이어그램 옆으로 타임라인을 하나씩 추가하며 각 액션이 서로 어떻게 상호작용하고 간섭하는지 볼 수 있다.

## 🌟 타임라인 다이어그램의 기본 규칙

### 1️⃣ 액션은 순서대로 실행되거나 동시에 실행됨

- 타임라인 다이어그램을 통해 순서대로 실행되는 액션과 동시에 나란히 실행되는 액션을 파악할 수 있다.
- 두 종류의 액션을 시각화함으로써 코드가 올바르게 동작하고 있는지 알 수 있다.

### 2️⃣ 두 액션이 순서대로 나타나면 **같은** 타임라인에 넣기

- 한 액션 다음에 다른 액션이 오는 경우 하나의 타임라인에서 순서대로 실행되게 그린다.
- 타임라인에는 액션만 그린다.
  - 계산은 실행 시점에 영향을 받지 않으므로 그리지 않는다.

### 3️⃣ 두 액션이 동시에 실행되거나 순서를 예상할 수 없다면 **분리된** 타임라인에 넣기

- 무작위 순서로 실행되는 두 액션은 타임라인 두 개로 분리하여 그린다.
  - 예: 두 개의 <code>setTimeout</code>에 등록된 콜백들은 비동기로 실행되므로 타임라인이 두 개이다.
- 액션이 서로 다른 스레드, 프로세스, 기계, 비동기 콜백에서 실행되면 서로 다른 타임라인에 표시한다.

## 🔎 액션 순서에 관한 두 가지 사실

- 모든 액션을 확인하고 어떤 순서로 실행되는지 이해하는 것은 중요하다.

### 1️⃣ ++와 +=는 사실 세 단계이다.

- <code>total++</code>의 연산 과정

```js
// 1. 읽기(액션)
let temp = total;
// 2. 더하기 (계산)
temp = temp + 1;
// 3. 쓰기 (액션)
total = temp;
```

- 계산인 두 번째 단계를 제외하고 다이어그램에 표시된다.
  |⬇️|
  |:--:|
  |total 읽기|
  |total 쓰기|

### 2️⃣ 인자는 함수를 부르기 전에 실행한다.

- 함수에 인자를 전달하면서 실행한다면 인자는 함수에 전달되기 전에 실행된다.
- <code>console.log(total)</code>의 실행 과정

```
const temp = total;
console.log(temp)
```

- 전역변수를 읽어(액션) 값을 콘솔에 로깅(액션)하는 코드이다.
  |⬇️|
  |:--:|
  |total 읽기|
  |console.log()|

## 📢 비동기 호출은 새로운 타임라인으로 그리자!

### 🔣 서로 다른 언어, 서로 다른 스레드 모델

- JS는 단일 스레드, 비동기 모델을 사용한다.

```
🤔 다른 언어에서는 어떤 모델을 사용하나요?
```

> 단일 스레드, 동기

- 기본적으로 멀티스레드를 지원하지 않아 모든 것이 순서대로 실행되고 입출력을 사용하면 끝날 떄까지 기다려야 한다.
- 예: PHP
- 스레드가 하나면 타임라인도 하나이지만, 네트워크를 통한 API 호출 등의 동작은 다른 타임라인이 필요하다.
- 장점
  - 시스템이 단순하다.
  - 메모리를 공유하지 않기 때문에 공유 자원을 많이 없앨 수 있다.

> 단일 스레드, 비동기

- 예: JS
- 입출력의 결과는 콜백으로 받을 수 있지만 언제 끝날지 알 수 없어 다른 타임라인에 표현해야 한다.

> 멀티 스레드

- 예: Java, Python, Ruby, C, C#
- 실행 순서를 보장하지 않아 프로그래밍하기 어렵다.
- 새로운 스레드가 생기는 경우 새로운 타임라인을 그려야 한다.

> 메시지 패싱 프로세스

- 예: Elixir, Erlang
- 서로 다른 프로세스를 동시에 실행할 수 있는 스레드 모델을 지원한다.
- 프로세스는 서로 메모리를 공유하지 않고 메시지로 통신한다.
- 서로 다른 타임라인에 있는 액션은 순서가 섞이지만 메모리를 공유하지 않는다.
  - 따라서 가능한 실행 순서가 많더라도 문제가 되지 않는다.

### 🏗️ 한 단계씩 타임라인 만들기

- 문서를 저장하는 과정에서 로딩 상태를 보여주는 코드 예시

```js
// 서버에 사용자를 저장한다. (ajax)
saveUserAjax(user, function () {
  // 사용자 로딩 표시를 감춘다.
  setUserLoadingDOM(false);
});

// 사용자 로딩 표시를 보여준다.
setUserLoadingDOM(true);

// 서버에 문서를 저장한다. (ajax)
saveDocumentAjax(document, function () {
  // 문서 로딩 표시를 감춘다.
  setDocLoadingDOM(false);
});

// 문서 로딩 표시를 보여준다.
setDocLoadingDOM(true);
```

1. 첫 번째 줄

- <code>saveUserAjax( )</code>
- 아직 타임라인이 없으므로 새로운 타임라인을 만든다.

2. 두 번째 줄

- 콜백 안에 위치해 있다.
- 콜백은 비동기로 실행되므로 요청이 끝나는 시점에 언젠가 실행된다.
- 비동기 콜백은 새로운 타임라인이 필요하다.
- 콜백이 ajax 함수 뒤에 실행된다는 사실을 점선으로 표시한다.
  - 점선은 순서를 제한한다.
  - 요청을 보내기 전에 응답을 받을 수는 없기 때문!

3. 네 번째 줄

- <code>setUserLoadingDOM( )</code>
- 콜백이 아니므로 원래 타임라인에서 실행된다.

5. 다섯 번째 줄

- <code>saveDocumentAjax( )</code>
- ajax 호출 자체는 콜백 밖에 있으므로 원래 타임라인에 그린다.

6. 여섯 번째 줄

- 콜백 안에 있는 코드이므로 새로운 타임라인에 그린다.
- 미래에 응답이 도착하는 시점에 실행되지만 네트워크 상황을 예측할 수 없어 정확히 언제 실행될지 알 수 없다.

7. 여덟 번쨰 줄

- 마지막 액션은 특별한 것이 없으므로 원래 타임라인에 그린다.

> 완성된 타임라인

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/2fb424ad-3ad6-44d2-b089-1773391d1fe7" width="60%"/>

```
👩‍🏫 여기서 우리는 타임라인 다이어그램을 통해 두 가지 사실을 알 수 있습니다.
1. 순서대로 실행되는 코드에도 두 가지 종류가 있습니다.
2. 동시에 실행되는 코드는 순서를 예측할 수 없다는 것을 알 수 있습니다.
```

### 🤖 순서대로 실행되는 코드 구분하기

> 🙆‍♀️ 순서가 섞일(**_interleave_**) 수 있는 코드

- 서로 다른 타임라인에 있는 액션은 순서가 섞일 수 있다.
- 두 액션 사이에 시간이 얼마나 걸리는지 모르므로 다른 타임라인의 액션과 순서가 섞일 수 있다.
- 여러 스레드에서 동시에 수행되는 경우 발생한다.
<hr/>

- 액션은 박스로 표시하고 액션 사이에 걸리는 시간은 선으로 표시한다.
  - 액션과 액션 사이에 걸리는 시간에 따라 길이가 결정된다.
  - 그럼에도 불구하고 액션1과 액션2 사이에 시간이 얼마나 걸릴지 알 수 없다.

> 🙅‍♀️ 순서가 섞이지 않는 코드

- 두 액션이 차례로 실행되고 그 사이에 다른 작업이 끼어들지 못한다.
  - 예: JS 스레드 모델에서 동기화된 액션들
- 런타임이 자체적으로 구현해주거나 프로그래밍을 통해 구현할 수 있다.

### 👾 순서를 예측할 수 없는 동시에 실행되는 코드

- 타임라인 다이어그램에서 동시에 실행되는 코드는 순서를 예측할 수 없다.
- 타임라인에서 액션이 나란히 표현되어 있더라도 두 액션이 항상 정확히 동시에 실행된다는 의미가 아니다.
- 타임라인 다이어그램을 볼 때는 선의 길이나 액션이 정렬된 위치와 상관없이

> 가능한 순서

- 타임라인이 실행 가능한 방법
- 여러 개의 타임라인은 시간에 따라 다양한 방식으로 실행될 수 있다.

## 💡 좋은 타임라인의 원칙

- 가능한 실행 순서의 개수 공식

  <img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/d4723d1a-cf92-4ef7-a2d3-e9650756bd64" width="30%"/>

### 1️⃣ 타임라인은 적을수록 이해하기 쉽다.

- 타임라인이 하나라면 모든 액션은 앞의 액션 다음에 바로 실행되므로 가장 이해하기 쉽다.
- 멀티스레드, 비동기 콜백, 클라이언트-서버 간 통신 등을 사용하려면 새로운 타임라인이 필요하다.
- 위의 공식에서 t를 줄인다면 훨씬 이해하기 쉬운 시스템이 된다.

### 2️⃣ 타임라인은 짧을수록 이해하기 쉽다.

- 타임라인의 단계(위의 공식에서 a)를 줄인다면 실행 가능한 순서의 수도 많이 줄어들기 때문에 이해하기 쉬운 타임라인을 만들 수 있다.

### 3️⃣ 공유하는 자원이 적을수록 이해하기 쉽다.

- 서로 다른 타임라인에 있는 두 액션이 서로 자원을 공유하지 않는다면 실행 순서에 신경을 쓸 필요가 없다.
- 실행 가능한 순서의 개수가 줄어들지 않더라도 신경써야 할 실행 가능한 순서를 줄일 수 있다.

### 4️⃣ 자원을 공유한다면 서로 조율해야 한다.

- 공유 자원을 3️⃣번에서 많이 없애더라도 남아있는 공유 자원들은 타임라인 간에 안전하게 공유되어야 한다.
- 안전하게 공유
  - 올바른 순서대로 자원을 쓰고 돌려준다.
- 타임라인 간 조율
  - 올바른 결과를 주지 않는 실행 순서를 없애는 것

### 5️⃣ 시간을 일급으로 다룬다.

- 타임라인을 다루는 재사용 가능한 객체를 만들면 액션의 순서와 타이밍을 맞추는 것을 쉽게 만들 수 있다.

## 🪡 JS의 단일 스레드

- JS는 스레드가 하나이다.
  - 이러한 JS의 스레드 모델은 타임라인이 자원을 공유하면서 생기는 문제를 줄여준다.
  - 하나의 메인 스레드만 있기 때문에 대부분의 액션을 하나의 박스로 표현할 수 있다.
- 전역변수를 바꾸는 동기 액션은 타임 라인이 서로 섞이지 않는다.
- 비동기 호출은 미래의 알 수 없는 시점에 런타임에 의해 실행된다.
- 두 동기 액션은 동시에 실행되지 않는다.

### 🤔 Java의 스레드 모델과 어떠한 차이가 있을까?

> java

```java
// 1. read x
int x = 0;
public void addToX(int y) {
// 2. x + y
// 3. store x + y
  x += y;
}
```

- Java는 멀티 스레드 모델을 사용한다.
- Java에서 두 스레드가 변수를 공유할 때, +=는 실제로는 세 단계로 실행된다.
  - 위의 코드에서 +는 계산이므로 타임라인에 표시하지 않는다.
  - 만약 두 스레드가 위의 addToX()를 동시에 실행한다면 실행 순서가 섞여 여러 가지 결과가 나온다.

> JS

- 스레드가 하나이므로 위와 같은 문제가 생기지 않는다.
- JS에서 스레드를 사용한다면 같은 스레드를 계속 사용하는 것이고, 두 액션이 동시에 실행될 일도 없다.
- JS에서는 위의 read와 store 사이에 다른 액션이 끼어들지 않으므로 같은 박스에 들어간다.

<hr/>

- 일반적인 절차적 프로그래밍으로 공유변수를 읽고 쓸 때는 위처럼 타임라인에 대해 고민할 필요가 없다.
- 하지만 비동기 콜백에서는 문제가 생길 수 있다.
  - 비동기 호출은 미래의 알 수 없는 시점에 런타임에 의해 실행되므로 박스 사이 선의 길이가 가변적이다.
- 따라서 JS에서 어떤 동작이 동기인지 비동기인지 아는 것은 중요하다!

5️⃣

## 🚥 JS의 비동기 큐

- 브라우저에서 동작하는 JS 엔진은 **작업 큐**라는 큐를 가지고 있다.
  - Queue: 가장 먼저 입력된 자료를 가장 먼저 처리하는 선형 자료 구조
- 작업 큐는 **이벤트 루프**에 의해 처리된다.
- 이벤트 루프는 큐에서 작업 하나를 꺼내 실행하고 완료되면 다음 작업을 꺼내 실행하는 것을 무한히 반복한다.
- 이벤트 루프는 하나의 스레드에서 처리하므로 두 개의 작업이 동시에 진행될 수 없다.

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/b0f59224-3adf-4de4-9bf9-a2dafc395036" width="50%" />

```
1️⃣ 비동기 동작을 호출하면 콜백은 작업 큐에 추가된다.
2️⃣ 마우스 클릭 같은 이벤트 발생 시 작업이 큐에 추가된다.
3️⃣ 큐는 들어온 순서대로 작업을 처맇나다.
4️⃣ 이벤트 루프 스레드에서 코드가 실행된다.
5️⃣ 이벤트 루프는 큐의 가장 앞에 있는 작업을 꺼내 실행하고 다음 작업을 처리한다.
```

### 🤔 작업이란 무엇일까?

- 이벤트 데이터 + 이벤트를 처리할 콜백
- 이벤트 루프는 이벤트 데이터를 인자로 해서 콜백을 부른다.
  - 콜백: 이벤트 루프가 실행할 함수
- 이벤트 루프는 단순히 첫 번째 인자에 이벤트 데이터를 넣어 콜백 함수를 실행한다.

### 🤔 작업은 큐에 어떻게 들어갈까?

- 이벤트 발생 시 큐에 작업이 추가된다.
  - 이벤트: 마우스 클릭, 키보드 입력, AJAX 이벤트
  - 콜백 함수가 있는 버튼에 이벤트 발생 시 콜백 함수와 클릭에 대한 정보(이벤트 데이터)가 큐에 추가된다.
- 어떠한 이벤트도 예상할 수 없으므로 이벤트는 예측 불가능한 시점에 작업 큐에 들어간다.
  - 들어간 작업은 나중에 작업 큐에서 온전히 가져온다.

### 🤔 작업이 없을 때 엔진은 무엇을 할까?

- 처리할 작업이 없는 경우 이벤트 루프는 대기 상태로 들어가고 전원을 아낀다.
- 또는 가비지 컬렉션 등의 관리 작업을 한다.

## 🧞 AJAX와 이벤트 큐

### 🤖 AJAX

- Asynchronous JavaScript And XML (실제로는 XML을 사용하지 않지만 용어에 남아있다.)
- 브라우저에 기반을 둔 웹 요청
- 일반적으로 브라우저에서 서버와 통신할 때 사용한다.

### 🤔 어떤 과정을 거쳐 실행될까?

```
1️⃣ JS에서 AJAX 요청을 만든다.
2️⃣ 네트워크 엔진이 AJAX 요청을 처리하기 위해 요청 큐에 넣는다.
    - 네트워크 엔진은 연결을 맺고 캐싱을 하고 AJAX 이벤트를 작업 큐에 넣는 일을 한다.
    - 요청 큐에 작업이 추가되어 코드는 계속 실행되므로 요청이 완료될 때까지 기다릴 필요가 없다.
3️⃣ 요청에 대해 웹 서버가 응답한다.
4️⃣ 이벤트 루프에서 코드가 실행되고 새로운 요청을 만든다.
```

- 많은 언어가 동기 요청 방식을 사용한다.
  - 이 방식에서는 요청이 완료되어야 다음 코드를 진행할 수 있다.
- JS에서 AJAX를 사용하는 부분은 비동기이다.
  - 네트워크 환경은 예측할 수 없으므로 응답은 요청 순서대로 오지 않는다.
  - AJAX 콜백은 요청 순서와 상관없이 작업 큐에 들어간다.

### 🤔 요청에 대한 응답을 기다리지 않는다면, 응답을 어떻게 받을까?

- AJAX 요청을 만들 떄 요청에 관련된 다양한 이벤트 콜백을 등록할 수 있다.
  - 콜백: 이벤트가 발생했을 때 실행되는 함수
  - 응답은 비동기 콜백으로 처리할 수 있다.
- 응답은 요청 순서대로 오지 않는다.
- 요청이 처리되는 동안 네트워크 엔진에 의해 다양한 이벤트가 발생한다.
  - 많이 사용되는 이벤트: load, error
  - <code>load</code>: 응답이 모두 다운로드 되었을 때 발생하는 이벤트
  - <code>error</code>: 뭔자 잘못된 경우 발생하는 이벤트

## ✂️ 타임라인 단순화하기

- 액션을 확인하고, 각 액션을 그리고 나면, 플랫폼의 스레드 모델에 따라 다이어그램을 단순하게 만들어야 한다.

```
👩‍🏫 JS에서 다이어그램을 단순화하기 위해 필요한 두 단계가 있습니다.
```

### 1️⃣ 하나의 타임라인에 있는 모든 액션을 하나로 통합한다.

- JS는 스레드가 하나이기 때문에 액션은 순서가 섞이지 않고 하나의 타임라인에서 실행된다.
- 타임라인은 다른 타임라인이 실행되기 전에 완료되므로 타임라인에 있는 모든 액션을 박스 하나에 넣는다.
- 다이어그램에 점선이 있다면 타임라인 끝으로 옮긴다.
- JS 런타임은 가능한 많은 실행 순서를 없애고 코드 실행을 단순화할 수 있다.

### 2️⃣ 타임라인이 끝나는 곳에서 새로운 타임라인이 하나 생기는 경우 통합한다.

- 첫 번째 타임라인이 끝나는 곳에 새로운 타임라인이 **하나만** 생길 때 통합한다.
  - 두 개 이상 생기는 경우 통합하지 않는다.

## 📖 완성된 타임라인 읽기

- 타임라인 다이어그램으로 가능한 액션의 실행 순서를 이해하면 코드가 제대로 동작하는지 알 수 있다.
- 잘 동작하지 않는 실행 순서로 버그를 찾을 수 있다.

### 💡 두 종류의 순서 구분하기

> 확실한 순서

- 모든 액션이 같은 타임라인에서 실행되는 경우 액션이 순서대로 실행된다는 것을 알 수 있다.
- 점선이 있기 때문에 다른 타임라인이 실행되기 전에 끝난다는 것도 알 수 있다.

> 불확실한 순서

- 서로 다른 타임라인에 있는 두 개의 콜백은 여러 가지 순서로(동시에, 왼쪽/오른쪽 먼저) 실행될 수 있다.
- JS는 스레드 하나에서 액션을 실행하므로 동시에 두 액션이 실행되는 일은 없다.
- 어떤 AJAX 응답이 먼저 오는가에 따라 실행 순서가 달라질 수 있다.
- 항상 순서대로 로딩 표시를 하고 콜백에서 감추도록 구현하면 문제 없는 코드를 만들 수 있다.

## 🛒 add-to-cart 타임라인 단순화하기

### 1️⃣ 액션을 확인한다.

```js
function add_item_to_cart(name, price, quantity) {
  // 1. cart 읽기, 2. cart 쓰기 > 전역변수를 읽고 씀
  cart = add_item(cart, name, price, quantity);
  calc_cart_total();
}

function calc_cart_total() {
  // 3. total = 0 쓰기
  total = 0;
  // 4. cart 읽기, 5. cost_ajax 호출하기
  cost_ajax(cart, function (cost) {
    // 6. total 읽기, 7. total 쓰기
    total += cost;
    // 8. cart 읽기, 9. shipping_ajax 호출하기
    shipping_ajax(cart, function (shipping) {
      // 10. total 읽기, 11. total 쓰기
      total += shipping;
      // 12. total 읽기, 13. update_total_dom 호출하기
      update_total_dom(total);
    });
  });
}
```

- 코드 안에 총 13개의 액션과 두 개의 비동기 콜백이 있다.

### 2️⃣ 순서대로 실행되거나 동시에 실행되는 액션을 그린다.

- 확인된 모든 액션(13개)는 다이어그램에 있어야 한다.
- 각 비동기 콜백(2개)은 다른 타임라인에 있어야 한다.
  - <code>const_ajax( )</code>, <code>shipping_ajax( )</code>는 ajax 요청이므로 콜백은 새로운 타임라인에 그린다.

> 완성된 다이어그램

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/cd5afbbd-b88a-4822-9789-209157fa8ec9" width="60%" />

### 3️⃣ 플랫폼에 특화된 지식을 사용해 다이어그램을 단순하게 만든다.

> **💡1** : 하나의 타임라인에 있는 모든 액션을 하나로 통합하기

- JS는 하나의 스레드에서 모든 코드를 실행하므로 현재 타임라인에 다른 스레드가 끼어들지 않는다.
- 따라서 타임라인에 있는 액션이 서로 섞일 가능성이 없으므로 같은 타임라인 상의 모든 액션을 박스 하나에 넣는다.

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/ddf34eb3-eee8-4315-b5c6-4085b834f77b" width="60%" />

> **💡2** : 타임라인이 끝나는 곳에서 새로운 타임라인이 하나 생긴다면 통합하기

- 다이어그램에 있는 타임라인은 새로운 타임라인이 시작할 때 끝난다.
- 각 타임라인은 AJAX 호출을 하면서 끝나고, 콜백 하나가 다음 작업을 이어서 한다.
- 따라서 모든 타임라인을 하나로 합칠 수 있다.

<p align="center"><img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/f31fd0c2-5383-4f94-8e01-8a62eb91adc2" width="25%" /></p>

- 이때 3-1을 적용해 모든 액션을 하나의 박스에 넣으면 안 된다.
  - 다른 타임라인에 액션이 생길 경우 각 박스의 순서는 섞일 가능성이 있기 때문!

## 👥 타임라인을 나란히 보면 문제가 보인다!

- 위의 다이어그램이 두 개 나란히 놓여 있는 경우 두 번 클릭했음을 나타낸다.
- 다른 타임라인에 있고 박스는 떨어져있으므로 순서가 섞일 수 있다.

### 🙆‍♀️ 두 번 천천히 클릭하는 경우

- 첫 번째 클릭의 마지막 단계가 끝나고(첫 번째 타임라인이 완료되고) 두 번째 클릭이 시작한다.
- 순서가 서로 섞일 수 있는 문제를 명확하게 하려고 단계 사이의 선을 늘린다.
  - 이를 통해 가능한 실행 순서 중 특정 순서를 강조할 수 있다.
- DOM에 올바른 결과가 표시된다.

### 🙅‍♀️ 빠르게 두 번 클릭하는 경우

- 첫 번째 클릭 이벤트가 발생하고 이에 해당하는 AJAX 응답이 조금 늦게 도착하는 사이에 두 번째 클릭이 시작된다.
- DOM에 잘못된 결과가 표시된다.
- 타임라인에 클릭 핸들러가 어디에 나타나는지에 따라 액션의 순서가 달라지고, 각 단계가 섞이는 것을 막을 수 없다.

### ⚠️ 자원을 공유하는 타임라인은 문제가 생길 수 있다!

- 공유하는 자원을 없앰으로써 문제를 해결할 수 있다.
- 두 단계가 자원을 공유할 경우 둘 사이의 순서가 중요하다.
- 두 타임라인이 같은 전역변수를 사용하면, 실행 순서가 섞인 상태에서도 각 타임라인이 하나의 전역변수에 접근하므로 문제가 발생한다.

> **💡1** : 전역변수를 지역변수로 바꾸기
> <img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/4cf323d5-3ca6-47a2-9963-cde3e0af3811" width="25%"/>

> **💡1** : 하나의 타임라인에 있는 모든 액션을 하나로 통합하기
> <img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/fc93ea4b-df7e-4424-8906-0edc75e4a58c" width="25%"/>

```
👩‍🏫 하지만 아직 문제가 남아있습니다! DOM 자원을 여전히 공유하고 있기 때문입니다.
```

### 🧐 TRUE or FALSE?

1.  두 타임라인은 자원을 공유할 수 있다? ➡️ **_TRUE_**
2.  자원을 공유하는 타임라인이 자원을 공유하지 않는 타임라인보다 안전하다? ➡️ **_FALSE_**
3.  같은 타임라인에 있는 두 액션은 서로 자원을 공유하지 않도록 해야 한다? ➡️ **_FALSE_**
4.  계산은 타임라인에 그릴 필요가 없다? ➡️ **_TRUE_**
5.  같은 타임라인에 있는 두 액션은 동시에 실행된다? ➡️ **_FALSE_**
6.  JS는 스레드가 하나이므로 타임라인을 무시해도 된다? ➡️ **_FALSE_**
7.  서로 다른 타임라인에 있는 두 액션은 동시에 실행되거나 한 방향이 먼저 실행될 수 있다? ➡️ **_TRUE_**
8.  공유하는 전역변수를 없애는 방법은 인자나 전역변수를 사용하는 것이다? ➡️ **_TRUE_**
9.  타임라인 다이어그램을 통해 소프트웨어가 동작할 때 실행 가능한 순서를 이해하기 좋다? ➡️ **_TRUE_**
10. 자원을 공유하는 타임라인은 타이밍 문제가 생길 수 있다? ➡️ **_TRUE_**

### 📢 비동기 호출의 원칙

> 🤖 동기 함수

- 호출하는 곳에서 리턴값을 사용할 수 있다.
- 액션을 빼내기 위해 액션을 부르는 곳은 리턴값으로 바꾸고, 액션에 리턴값을 인자로 전달한다.

> 🤖 비동기 함수

- 비동기 호출은 바로 리턴이 되지만 결괏값은 콜백이 호출되어야 얻을 수 있다.
  - 동기화된 함수와 같이 결괏값을 리턴값으로 줄 수 없다.
- 미래의 어떤 시점에 **콜백**을 통해 결과를 받는다.
  - 결과가 준비되었을 때 결과를 인자에 넣어 콜백을 호출한다.
- 액션을 뺴내기 위해 액션을 부르는 곳은 콜백을 부르도록 바꾸고, 액션을 콜백으로 전달한다.

```
🤠 비동기 호출에서 명시적인 호출을 위해 리턴값 대신 콜백을 사용할 수 있습니다!
```

> 비동기 함수에서 리턴값을 사용하지 못하는 이유

- 정확히는 리턴은 할 수 있지만 일반적으로 원하는 리턴값을 사용할 수 없는 것이다.

```js
function get_data_ajax() {
  let data = [];
  data_ajax((arg) => {
    get_element_ajax((el) => {
      data.push(arg + el);
    });
  });
  return data;
}
```

- 위의 코드에서 <code>data_ajax()</code>와 <code>get_element_ajax()</code>에 전달된 콜백은 네트워크 응답이 도착해야 실행된다.
  - 그때까지 data의 값은 초기값 그대로이다.
- AJAX 요청이 끝나기 전에 data 값이 리턴된다.
- 따라서 함수는 리턴을 하지만, 원하는 값이 아닌 빈 배열만을 리턴하게 된다.

```
🤔 호출된 data_ajax()는 어떻게 되나요?
```

- <code>data_ajax()</code>는 네트워크 요청이므로 요청을 네트워크 엔진으로 보낸 뒤 바로 다음 코드로 넘어간다.
- 다음 코드는 return 구문이므로 data 값이 리턴된다.
- 나중에 AJAX 요청이 완료되면 완료 이벤트(load)가 작업 큐에 들어간다.
- 이후 이벤트 루프가 작업 큐에 있는 이벤트를 꺼내 콜백을 호출하게 된다.

<hr/>

- 다시 말해, 비동기 함수도 실제로 리턴을 할 수 있지만 리턴값은 동기화된 코드에서 계산된 값과 일치하지 않는다
  - 비동기 코드에서 계산된 값이 이벤트 루프에서 나중에 실행되므로 즉시 리턴값으로 받을 수 없기 때문!
  - 즉시 리턴할 때에는 호출 스택이 비어있게 된다.
- 비동기 코드에서의 결괏값은 콜백을 통해 전달해야 한다.
