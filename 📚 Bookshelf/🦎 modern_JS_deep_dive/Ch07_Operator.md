<p align="center"><img src="https://velog.velcdn.com/images/hamjw0122/post/ee58d609-bd04-4782-a7a6-23cdcb48c7d6/image.png" width="60%"/></p>

#### 💡 피연산자

- 연산의 대상
- '값'(명사. 값으로 평가될 수 있는 표현식)

#### 💡 연산자

- 피연산자를 연산하여 새로운 값을 만듦(동사)

#### 💡 연산자 표현식

- 피연산자+연산자
- 값으로 평가될 수 있는 표현식

## 🔣 산술 연산자

- 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만듦

- 산술 연산이 불가능한 경우 NaN 반환

### 📌 이항 산술 연산자

- 피연산자의 값을 변경하는 부수효과 X → 새로운 값 생성

- +(덧셈), -(뺄셈), \*(곱셈), /(나눗셈), %(나머지)

### 📌 단항 산술 연산자

![](https://velog.velcdn.com/images/hamjw0122/post/8bcb35ea-7906-49fe-bc21-83de70610b0e/image.png)

> ✨ **증가(++)/감소(--) 연산자의 위치**

#### 📍 전위 증가/감소 연산자

- 피연산자 앞에 위치
- 먼저 피연산자의 값을 증가/감소시킨 후 다른 연산 수행

```js
let num = 10,
  result;

result = ++num;
console.log(result, num); // 11, 11
```

#### 📍 후위 증가/감소 연산자

- 피연산자 뒤에 위치
- 먼저 다른 연산 수행 후 피연산자의 값을 증가/감소시킴

```js
result = num--;
console.log(result, num); // 11, 10
```

- +/- 단항 연산자는 숫자 타입이 아닌 피연산자에 사용할 경우 피연산자를 숫자 타입으로 변환하여 반환함
- 피연산자 자체를 변경하는 것은 X. 변환한 값을 생성하여 반환하는 것으로 부수 효과 X

```js
let a = "100";

console.log(+a); // 100
console.log(a); // '100'

a = true;
console.log(-a); // -1

a = "hi";
console.log(-a); // NaN (문자열은 숫자로 타입 변환 불가)
```

#### 📍 문자열 연결 연산자

- - 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함

- 암묵적 타입 변환(타입 강제 변환) 발생 가능 (아래 코드 참조)

```js
1 + true; // 2 (true는 1로 타입 변환됨)

1 + false; // 1 (false는 0으로 타입 변환됨)

1 + null; // 1 (null은 0으로 타입 변환됨)

1 + undefined; // NaN (undefined는 숫자로 타입 변환 x)
```

## 🔣 할당 연산자

- 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당함 (부수 효과 O)

- =, +=, -=, \*=, /=, %=

  - a += 1 은 a = a+1과 동일한 표현

- 할당문은 변수에 값을 할당하는 부수 효과가 있을 뿐만 아니라 할당된 값으로 평가되므로 값으로 평가되는 표현식에 해당한다.
  - ➡️ 연쇄 할당도 가능

```js
let a, b, c;

a = b = c = 5;
// 1) c = 5: 할당된 숫자 값 5로 평가됨
// 2) b = 5: 할당된 숫자 값 5로 평가됨
// 3) a = 5: 할당된 숫자 값 5로 평가됨
```

## 🔣 비교 연산자

- 좌항과 우항의 피연산자 비교 후 결과를 boolean 값으로 반환

- 부수효과 발생 X

### 📌 동등/일치 비교 연산자

![](https://velog.velcdn.com/images/hamjw0122/post/73c9847a-5fbb-42b8-a71a-da06af28e74d/image.png)

- 안티 패턴이지만 아래의 예제와 같은 상황이 발생할 수 있으므로 동등 비교 연산자의 사용은 지양하는 것이 좋다.

```js
0 == ""; // false
"0" == ""; // true
false == null; // false
false == "0"; // true
false == undefined; // false
false == "false"; // false
// 결과를 예측하기 어렵다.
```

- **NaN**이 자신과 일치하지 않는 유일한 값임에 유의하여야 한다.

```js
NaN === NaN; // false

// ﻿값이 NaN인지 조사하기 위해서는 Number.isNaN을 사용해야 함
Number.isNaN(NaN); // true
Number.isNaN(1 + undefined); // true
```

- JS에는 양의 0과 음의 0이 존재한다. ➡️ 둘을 동등/일치 비교하면 true

```js
0 == -0; // true
0 === -0; // true
```

- ES6에서 도입된 Object.is 메서드를 사용하면 NaN과 양/음의 0을 정확하게 검사할 수 있다.

```js
Object.is(-0, +0); // false
Object.is(NaN, NaN); // true
```

### 📌 대소 관계 비교 연산자

- 피연산자의 크기를 비교하여 불리언 값 반환

```js
>, <, >=, <=
```

## 🔣 삼항 조건 연산자

- 두 번째 피연산자 또는 세 번째 피연산자로 평가되는 표현식
- 조건식의 평가 결과에 따라 반환할 값 결정 (부수 효과 X)

> **_조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값_**

```
1️⃣ 첫 번째 피연산자(조건식)를 평가한다.

2️⃣ 1️⃣의 결과가 true인 경우 두 번째 피연산자를 반환한다.

3️⃣ 1️⃣의 결과가 false인 경우 세 번째 피연산자를 반환한다.
```

```js
let a = 5;

// 5 % 3은 2이고, 2는 true로 암묵적 타입 변환된다. (0이 나오면 false로 암묵적 타입 변환)
let result1 = a % 3 ? "3의 배수가 아닙니다." : "3의 배수입니다.";

console.log(result); // 3의 배수가 아닙니다.

// 삼항 조건 연산자 표현식은 if ... else 문을 사용하여 유사하게 처리할 수 있다.
let b = 5,
  result2;

if (b % 3) result = "3의 배수가 아닙니다.";
else result = "3의 배수입니다.";

console.log(result); // 3의 배수가 아닙니다.
```

### ⚠️ 주의해야 할 점

- 삼항 조건 연산자와 if ... else문이 유사하게 처리됨에도 불구하고 둘 사이에는 중요한 차이가 있다는 것이다.

|         삼항 조건 연산자          |               if ... else 문                |
| :-------------------------------: | :-----------------------------------------: |
| 값으로 평가할 수 있는 표현식인 문 | 표현식이 아닌 문으로, 값처럼 사용할 수 없음 |

## 🔣 논리 연산자

![](https://velog.velcdn.com/images/hamjw0122/post/fe7f58dd-8afe-4314-ac69-2fbef221885f/image.png)

- 부수 효과 없음

- 논리 부정 연산자는 언제나 boolean 값 반환
  - 피연산자가 반드시 boolean 값일 필요 없음 (암묵적 타입 변환)

```js
!0; // true
!"Hello World"; // false
```

- 논리합/논리곱 연산자 표현식의 평가 결과는 boolean 값이 아닐 수도 있음

## 🔣 쉼표 연산자(,)

```
1️⃣ 왼쪽 피연산자부터 차례대로 피연산자 평가

2️⃣ 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과 반환
```

```js
let a, b, c;

(a = 2), (b = 4), (c = 6); // 6
```

## 🔣 그룹 연산자('()')

- 자신의 피연산자인 표현식을 가장 먼저 평가함

- 연산자 우선 순위가 가장 높음 ➡️ 그룹연산자를 사용하여 연산자의 우선순위 조절

```js
10 * 2 + 5; // 25

10 * (2 + 5); // 70
```

## 🔣 typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환함

- 7가지 문자열 중 하나 반환 ("string", "number", "boolean", "undefined", "symbol", "object", "function")

```js
typeof ""; // "stirng"
typeof NaN; // "number"
typeof []; // "object"
typeof {}; // "object"
typeof new Date(); // "object"
typeof /test/gi; // "object" (정규표현식)
typeof function (num) {}; // "function"
```

- typeof null 이 "null"이 아닌 "object"임에 주의하자!
  - JS 첫 번째 버전의 버그이나 기존 코드에 영향을 줄 수 있어 아직까지 수정되지 못하고 있음

```js
typeof null; // "object"

// 값이 null 타입인지 확인할 때는 일치 연산자(===) 사용
let a = null;

typeof a === null; // false
a === null; // true
```

- 선언하지 않은 식별자를 typeof 연산자로 연산하면 undefined를 반환함 (에러 발생 X)

```js
typeof unknown; // undefined (unknown 식별자 선언한 적 없음)
```

## 🔣 지수 연산자(ES7 문법)

- 좌항의 피연산자를 밑, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값 반환
- 할당 연산자와 함께 사용 가능

```js
5 ** 2; // 25
5 ** 0; // 1

// 음수를 거듭제곱의 밑으로 사용하려면 괄호로 묶어야 함
-5 ** 2; // SyntaxError: ~ (에러 발생)
(-5) ** 2; // -25
```

- 이항 연산자 중 우선 순위가 가장 높음

```js
let num = 10;
num **= 2; //100
```

## 🔣 그 외의 연산자

|   연산자   |                            개요                             |
| :--------: | :---------------------------------------------------------: |
|     ?.     |                    옵셔널 체이닝 연산자                     |
|     ??     |                      null 병합 연산자                       |
|   delete   |                        프로퍼티 삭제                        |
|    new     |         생성자 함수 호출 시 사용하여 인스턴스 생성          |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
|     in     |                   프로퍼티 존재 여부 확인                   |

## 🔣 연산자의 부수 효과

- 대부분의 연산자는 다른 코드에 영향을 주지 않고 새로운 값 생성

- 부수효과가 있는 연산자

  - 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자

- delete 연산자

```js
let obj = { a: 1 };

delete obj.a;
console.log(obj); // {} (객체의 프로퍼티를 삭제하는 부수효과)
```
