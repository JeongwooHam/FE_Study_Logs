## 🌟 MVVM 패턴 (MVVM Pattern)

<img src="https://github.com/JeongwooHam/FE_Study_Logs/assets/123251211/39f02d72-7e7f-439c-88c3-8c2f8efc31c9" />

- MVC의 컨트롤러가 **뷰모델 (View Model)**로 바뀐 패턴

> 뷰모델

- 뷰를 더 추상화한 계층
- 뷰와 모델 사이에서 중재자 역할을 수행한다.
- 뷰에서 발생하는 이벤트를 감지하고 해당 이벤트에 맞는 비즈니스 로직을 수행한다.
- 모델과 상호작용하여 데이터를 가져오거나 업데이트하고, 이를 뷰에 업데이트한다.
- 뷰에 표시할 데이터를 가공하여 제공하는 역할을 한다.
- 동작 과정
  ```
  1️⃣ 사용자의 액션이 뷰를 통해 들어온다.
  2️⃣ 뷰는 뷰모델로 액션을 전달한다.
  3️⃣ 뷰모델은 모델에게 데이터를 요청한다.
  4️⃣ 모델은 뷰모델에게 요청 데이터를 응답한다.
  5️⃣ 뷰모델은 응답받은 데이터를 가공하여 저장한다.
  6️⃣ 뷰는 데이터 바인딩을 사용하여 UI를 갱신한다.
  ```

<hr/>

- MVC 패턴과 다르게 커맨드와 데이터 바인딩을 가진다.

> 커맨드

- 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법

> 데이터 바인딩

- 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법
- 예: 뷰모델 변경 시 뷰가 변경된다.
- 데이터 바인딩으로 View와 ViewModel 사이의 의존성을 없앨 수 있다.

### 🤔 MVP 패턴과의 차이점

- MVP 패턴은 View와 Presenter 사이의 의존관계가 1:1이다.
- MVVM 패턴은 View와 ViewModel 사이의 관계가 1:N이다.

### 🟢 MVVM 패턴의 장점

- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원한다.
- 뷰 로직과 비즈니스 로직을 분리해 UI가 나오지 않아도 개발이 가능하므로 생산성 향상이 가능하다.
- UI를 별도의 코드 수정 없이 재사용할 수 있다.
  - 뷰와 뷰 모델이 1:N 관계이므로 중복되는 로직을 모듈화 해 재사용 가능하다.
- 의존성이 없으므로 단위 테스팅에 용이하다.

### 🔴 MVVM 패턴의 단점

- 데이터 바인딩에 대한 지식이 필요하므로 설계하기가 복잡하다.
- 뷰 모델이 과도하게 커질 수 있고, 데이터 바인딩으로 인한 메모리 소모가 심하다.

### ✨ `View.js`

- 반응형이 특징인 FE 프레임워크로, MVVM 패턴을 가진 대표적 프레임워크
- 함수 사용 없이 값 대입만으로 변수가 변경된다.
- 양방향 바인딩, `HTML`을 토대로 컴포넌트를 구축할 수 있다.
- 재사용 가능한 컴포넌트를 기반으로 UI 구축이 가능하다.
