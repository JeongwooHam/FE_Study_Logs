## 🌟 이터레이터 패턴 (Iterator Pattern)

- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
- 자료형의 구조와 관계 없이 순회할 수 있는 자료형이라면 이터레이터라는 하나의 인터페이스로 순회 가능하다.

### 🟢 이터레이터 패턴의 장점

> 캡슐화 및 분리

- 이터레이터 패턴으로 컬렉션의 구현과 반복 로직을 분리할 수 있다.
- 컬렉션의 내부 구조를 알 필요 없이 반복 작업을 수행할 수 있다.
- 객체 간의 결합도를 낮추고 코드의 유지보수성을 높일 수 있게 해준다.

> 유연성 및 확장성

- 새로운 컬렉션 타입이나 구조가 추가되더라도 이터레이터 인터페이스 구현 시 쉽게 적용할 수 있다.
- 이로써 코드의 재사용성과 확장성이 증가할 수 있다.
- 정방향 순회 뿐만 아니라 역방향이나 `filter` 등을 통한 특정 조건 기준 필터링 등 컬렉션의 순회 방법을 다양하게 구현할 수 있다.

### 🔴 이터레이터 패턴의 단점

> 추가 오버헤드

- 이터레이터 패턴으로 인해 추가적인 인터페이스나 클래스를 만들어야 하므로 작은 규모의 프로젝트에서는 이 작업이 불필요할 수 있다.

### ✨ JS의 이터레이터 패턴

- `set`과 `map`은 다른 자료 구조이지만 동일한 이터레이터 프로토콜 `for a of b`을 통해 순회한다.

```js
const map = new Map();
map.set("a", 1);
map.set("b", 2);
map.set("cccc", 3);
const set = new Set();
set.add(1);
set.add(2);
set.add(3);

for (let a of map) console.log(a);
for (let a of set) console.log(a);
/* 
[ 'a', 1 ]
[ 'b', 2 ]
[ 'c', 3 ]
1
2
3
*/
```

> Iterator Protocol

- 이터러블한 객체들을 순회할 때 쓰이는 규칙

> Iterable Object

- 반복 가능한 객체로 배열을 일반화한 객체
- 예: 문자열, set, map
