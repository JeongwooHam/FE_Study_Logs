## 🌟 노출 모듈 패턴 (Revealing Module Pattern)

- 즉시 실행 함수를 통해 `private`, `public` 같은 접근 제어자를 만드는 패턴

> `public` 접근 가능 여부

| 클래스에 정의된 함수 | 자식 클래스 | 외부 클래스 |
| :------------------: | :---------: | :---------: |
|          ⭕          |     ⭕      |     ⭕      |

> `protected` 접근 가능 여부

| 클래스에 정의된 함수 | 자식 클래스 | 외부 클래스 |
| :------------------: | :---------: | :---------: |
|          ⭕          |     ⭕      |     ❌      |

> `private` 접근 가능 여부

| 클래스에 정의된 함수 | 자식 클래스 | 외부 클래스 |
| :------------------: | :---------: | :---------: |
|          ⭕          |     ❌      |     ❌      |

> `즉시 실행 함수`

- 함수를 정의하자마자 바로 호출하는 함수
- 초기화 코드
- 라이브러리 내 전역 변수의 충돌 방지 등에 사용한다.

### 🟢 노출 모듈 패턴의 장점

> DX 친화적 접근 방식 제공

- 노출 모듈 패턴은 명시적으로 어떤 기능이나 속성을 외부에 노출할지 정의하므로 모듈을 사용하는 개발자에게 사용법을 명확히 전달할 수 있다.
- 명시적으로 `public` 메소드와 변수를 제공하여 가독성을 높일 수 있다.
- 모듈 내의 변수와 함수를 비공개로 유지하여 전역 네임스페이스에서의 변수 충돌을 방지함으로써 코드의 신뢰성을 높이고 예상치 못한 문제를 방지할 수 있다.

> 캡슐화

- 모듈의 구현 세부사항을 숨겨 외부에서 직접 접근이 어렵게 할 수 있다.
- 모듈의 내부 상태와 동작을 안전하게 유지할 수 있게 해주며, 다른 부분에 영향을 덜 주게 된다.
- 모듈의 내부 구현을 수정하더라도 외부에서 사용하는 코드는 영향을 받지 않는 한정적인 인터페이스만을 이용하므로, 유지보수가 용이하다.

### 🔴 노출 모듈 패턴의 단점

> `private` 메소드에 접근할 방법이 없음

- 노출 모듈 패턴에서는 비공개 함수에 대한 프로토타입에 직접 접근할 수 없다.
- 테스트와 같은 목적으로 프로토타입을 활용하려는 경우에 어려움을 줄 수 있다.
- 또한 해당 메소드에 대한 함수를 확장하거나 해당 메소드를 참조하는 `public` 메소드를 수정할 경우 어려움이 발생할 수 있다.

> 메모리 소모

- 노출 모듈 패턴에서 모듈의 인스턴스를 생성할 때마다 비공개 함수와 변수가 **클로저**를 생성하고, 이는 메모리 소비를 증가시킬 수 있다.
  - **클로저**: 해당 함수가 정의된 스코프에 있는 변수에 접근할 수 있는 함수와 그 함수가 참조하는 변수를 포함하는 구조
- 모듈을 여러 인스턴스로 생성하는 경우 및 모듈 인스턴스가 계속 유지되는 경우 크리티컬한 문제가 될 수 있다.

```js
function createModule() {
  let privateVariable = 10;

  function privateFunction() {
    console.log(privateVariable);
  }

  return {
    publicMethod: function () {
      privateFunction();
    },
  };
}

const moduleInstance1 = createModule();
const moduleInstance2 = createModule();
```

- 위의 함수에서 `moduleInstance1`과 `moduleInstance2`는 서로 독립된 클로저를 형성하게 된다.
  - 이는 메모리 소모가 두 배로 발생하는 문제를 야기할 수 있다.

### ✨ JS의 노출 모듈 패턴

- JS에는 `private`, `public` 같은 접근 제어자가 존재하지 않으므로 전역 범위에서 스크립트가 실행된다.
- 노출 모듈 패턴을 사용하여 이러한 접근 제어자를 구현할 수 있다.

```js
const accessModifier = (() => {
  const a = 1;
  const b = () => 2;
  const public = {
    c: 2,
    d: () => 3,
  };
  return public;
})();
console.log(accessModifier);
console.log(accessModifier.a);
// { c: 2, d: [Function: d] }
// undefined
```

- `a`와 `b`는 `private` 범위를 가지므로 다른 모듈에서 사용할 수 없다.
- `c`와 `d`는 `public` 범위를 가지므로 다른 모듈에서도 사용할 수 있다.
- JS 모듈 방식인 **_CJS(CommonJS)_** 모듈 방식은 노출모듈 패턴을 기반으로 구현되었다.
