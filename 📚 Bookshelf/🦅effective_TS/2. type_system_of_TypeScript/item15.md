## ✨ 동적 데이터에 인덱스 시그니처 사용하기

### 인덱스 시그니처

- 동적 데이터를 표현할 때 사용한다.
- 런타임까지 객체의 속성을 알 수 없는 경우에만 사용한다.

> **⚠️ 잘못된 인덱스 시그니처**

```ts
/**
 * @key
 * - 키의 위치만 표시하는 용도
 * - 타입 체커에서는 사용하지 않는 값
 * @string
 * - string | number | symbol의 조합이어야 한다.
 * - 보통 string을 사용한다.
 * @number
 * - 값의 타입
 * - 어떤 것이든 될 수 있다.
 */
type Something = { [key: string]: number };
```

1. 잘못된 키까지 모두 허용한다.
2. 특정 키가 필요하지 않다. (빈 객체도 가능하다.)
3. 키마다 다른 타입을 가질 수 없다.
4. 자동 완성 기능이 동작하지 않는다.

> `undefined` 사용하기

- 선언해 둔 열들이 런타임에 실제로 일치할지 보장할 수 없을 때
- 모든 열의 `undefined` 여부를 검사해야 한다.
- 번거로울 수 있으므로 상황에 따라 추가 여부를 판단해야 한다.

### 인덱스 시그니처 대신 사용할 수 있는 방법들

- 모델링 될 값이 제한되어 있는 경우 굳이 광범위하게 인덱스 시그니처를 사용할 필요가 없다.

> `Record` 사용하기

```ts
type Vector = Record<"x" | "y" | "z", number>;
```

> 매핑된 타입 사용하기

- 키마다 별도의 타입을 사용할 수 있다.

```ts
type Vector = { [k in "x" | "y" | "z"]: number };

type Diff = { [k in "a" | "b" | "c"]: k extends "a" ? number : boolean };
```
