## β¨ νƒ€μ…κ³Ό μΈν„°νμ΄μ¤μ μ°¨μ΄μ  μ•κΈ°

### κ³µν†µμ 

- μ •μλμ§€ μ•μ€ μ¶”κ°€ μ†μ„±μ— λ€ν•΄ μ¤λ¥κ°€ λ°μƒν•λ‹¤.
- μΈλ±μ¤ μ‹κ·Έλ‹μ²λ¥Ό μ‚¬μ©ν•  μ μλ‹¤.
  - `[key: string]: string`

> ν•¨μ νƒ€μ… μ •μν•κΈ°

- λ‹¨μν• ν•¨μ νƒ€μ…μ—μ„λ” Type Aliasκ°€ λ” νΈλ¦¬ν•λ‹¤.

```ts
type Tfunc = (x: string) => number;
interface Ifunc {
  (x: string): number;
}
```

> μ λ„¤λ¦­

```ts
type TGeneric<T> = {
  element: T;
};

interface IGeneric<T> {
  element: T;
}
```

> ν™•μ¥ κ°€λ¥μ„±

- μΈν„°νμ΄μ¤λ΅ νƒ€μ…μ„ ν™•μ¥ν•  μ μλ‹¤.
- Type Aliasλ΅ μΈν„°νμ΄μ¤λ¥Ό ν™•μ¥ν•  μ μλ‹¤. (`&`) β΅οΈ λ³µμ΅ν• νƒ€μ…μ„ ν™•μ¥ν•  μ μλ‹¤.

> ν΄λμ¤ κµ¬ν„ν•κΈ°

```ts
class TClass implements TState {
  element: string = "";
}

class IClass implements IState {
  element: string = "";
}
```

### Type Aliasμ μ°¨μ΄μ 

- μ λ‹μ¨ νƒ€μ…μ΄ μ΅΄μ¬ν•λ‹¤.

> μ λ‹μ¨ νƒ€μ… ν™•μ¥ν•κΈ°

```ts
// 1. λ§¤ν•‘ μΈν„°νμ΄μ¤ λ§λ“¤κΈ°
interface IMap {
  [name: string]: Type1 | Type2;
}

// 2. &λ΅ ν™•μ¥ν•κΈ°
type TMap = (Type1 | Type2) & { name: string };
```

- νν”κ³Ό λ°°μ—΄ νƒ€μ…μ„ κ°„κ²°ν•κ² ν‘ν„ν•  μ μλ‹¤.
  - μΈν„°νμ΄μ¤λ΅ λ”°λΌν•  κ²½μ° μ‚¬μ©ν•  μ μ—†λ” λ©”μ„λ“λ“¤μ΄ μƒκΈ΄λ‹¤.

```
π‘©β€π« κ°„κ²°ν•κ³  μΌκ΄€λ νƒ€μ… λλ” λ³µμ΅ν• νƒ€μ…μ—μ„ μ‚¬μ©ν•©μ‹λ‹¤!
```

### Interfaceμ μ°¨μ΄μ 

- **λ³΄κ°•**μ΄ κ°€λ¥ν•λ‹¤.
  - `μ„ μ–Έ λ³‘ν•©`: μ†μ„±μ„ ν™•μ¥ν•λ” κ²ƒ (β οΈ ν”„λ΅μ νΈ λ‚΄λ¶€μ—μ„ λ°μƒν•μ§€ μ•λ„λ΅ μ£Όμν•μ)
  - μ‚¬μ©μκ°€ λΉν‹μ„ μ±„μΈ μ μλ„λ΅ νƒ€μ… μ„ μ–Έ νμΌμ—μ„λ” μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ‹¤.

```
π‘©β€π« API νƒ€μ… μ„ μ–Έμ²λΌ λ³΄κ°•μ΄ ν•„μ”ν•  μ μλ” κ²½μ° μ‚¬μ©ν•©λ‹λ‹¤!
```
