<p align="center"><img src="https://velog.velcdn.com/images/hamjw0122/post/8c538f25-eebf-4a04-b572-ef7295e71212/image.png" width="60%"/></p>

## 💡 표현식과 문

### 📌 값(value)

- (표현)식이 평가되어 생성된 결과

- 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장됨

```js
var sum = 1 + 2;
```

- 위의 예시에서, 변수 이름이 기억하는 메모리 공간에 저장되는 것은 1+2가 아니라 1+2가 평가된 결과인 숫자 값 3이다.

### 📌 리터럴(literal)

- 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

- 값을 생성하기 위해 미리 약속한 표기법

- 사람이 이해할 수 있는 문자/기호로 기술된 리터럴은 JS 엔진에 의해 평가되어 값을 생성함
  - JS 엔진은 런타임에 리터럴을 평가해 값 생성

|      리터럴       |               예시                |
| :---------------: | :-------------------------------: |
|    정수 리터럴    |                 1                 |
| 부동소수점 리터럴 |                1.5                |
|   2진수 리터럴    |            0b01010101             |
|   8진수 리터럴    |               0o111               |
|   16진수 리터럴   |               0x41                |
|   문자열 리터럴   |         'hello', "world"          |
|   불리언 리터럴   |           true , false            |
|    null 리터럴    |               null                |
| undefined 리터럴  |             undefined             |
|    객체 리터럴    | { name: 'Ham', address: 'Seoul' } |
|    배열 리터럴    |             [1, 2, 3]             |
|    함수 리터럴    |           function() {}           |
| 정규표현식 리터럴 |             /[A-Z]+/g             |

### 📌 표현식(expression)

- 값으로 평가될 수 있는 문(statement)

- 평가되는 경우 새로운 값을 생성하거나 기존 값을 참조함

  - ➡️ 표현식은 값처럼 사용 가능하고, 다른 표현식의 일부가 되어 새로운 값 생성 가능

- 리터럴, 식별자(변수, 함수 등의 이름. 선언이 이미 존재한다고 가정), 연산자, 함수 호출 등의 조합

- 리터럴은 JS 엔진에 의해 평가되어 값을 생성하므로 그 자체로 표현식

### 📌 문

- **(명령)문**

  - 프로그램을 구성하는 기본 단위이자 최소 실행 단위
  - 문의 집합 ➡️ 프로그램

- **토큰**
  - 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소
  - 문을 구성함

### 📌 세미콜론(;)

- JS 엔진으로 하여금 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행하게 함

- 코드 블록({...}) 뒤에는 붙이지 않음 ➡️ 자체 종결성을 갖기 때문!

- 세미콜론 자동 삽입 기능(ASI)의 암묵적인 수행으로 생략 가능함

### 📌 표현식인 문과 표현식이 아닌 문

```
👩‍🏫 변수에 할당해 봄으로써 구별할 수 있습니다.
```

#### 🙆‍♀️ 표현식인 문

- 값으로 평가될 수 있는 문 → 변수에 할당 可

- 예) 할당문

```js
let foo = (x = 10);
```

- 위의 코드에서 'x=10'이라는 할당문은 표현식인 문으로, 값처럼 사용할 수 있고 따라서 변수에 할당하는 것도 가능하다.

#### 🙅‍♀️ 표현식이 아닌 문

- 값으로 평가될 수 없는 문 ➡️ 할당 시 에러 발생

- 예) 변수 선언문

- 크롬 개발자 도구에서 실행 시 완료 값(undefined) 출력 ➡️ 변수에 할당하거나 참조할 수 없음

## 💡 데이터 타입

### 📍 원시 타입

#### ✨ number

- 숫자 (정수와 실수 구분 없음)

- JS는 숫자 타입을 모두 실수로 처리함

- JS에서는 2진수, 8진수, 16진수 값을 참조하면 10진수로 해석됨

> ♾️ **Infinity**

- 양의 무한대
- 예) 10 / 0

> ♾️ **-Infinity**

- 음의 무한대
- 예) 10 / -0

> 🔣 **NaN**

- Not a Number. 산술 연산 불가
- 대소문자 구별에 유의할 것!
  - NAN, Nan, nan은 다른 값임

#### ✨ string

- 문자열

- 큰따옴표, 작은따옴표, 백틱(` `)으로 감쌀 수 있음

  - 키워드, 식별자 같은 토큰과 구분하기 위해 사용

- 변경 불가능한 값 (생성 시 변경 불가)

- 문자열 연산자 +를 사용해 연결 가능
  - 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작

#### ✨ boolean

- true, false

#### ✨ undefined

- 선언된 변수에 암묵적으로 할당되는 값

- 변수를 선언한 이후 값을 할당하지 않은 변수 참조 시 반환되는 값

- JS 엔진이 변수를 초기화할 때 사용하는 값

- 개발자가 의도적으로 할당하기 위한 값이 아님!

#### ✨ null

- 값이 없다는 것을 의도적으로 명시할 때 사용 (의도적 부재)

- 변수가 이전에 참조하던 값을 더 이상 참조하지 않기 위해 할당

- 이전 할당 값에 대한 참조를 명시적으로 제거
  - ➡️ JS 엔진이 해당 메모리 공간에 대해 가비지 콜렉션을 수행

#### ✨ symbol

- 변경 불가능한 원시 타입의 값(ES6에서 추가된 타입)

- 다른 값과 중복되지 않는 유일무이한 값

- 리터럴로 생성하는 다른 원시 값들과 다르게 Symbol 함수 호출로 생성

  - ➡️ 외부에 노출되지 않고, 중복되지 않는 유일무이한 값 생성

- 주로 객체의 유일무이한 프로퍼티 키를 만들기 위해 사용

### 📍 객체 타입 (object/reference)

- 객체, 함수, 배열 등

### 📍 템플릿 리터럴

- ES6부터 도입된 새로운 문자열 표기법

- 런타임에 일반 문자열로 변환되어 처리됨

- 백틱(` `)을 사용해 표현함

#### ✨ 멀티라인 문자열

- 일반 문자열과 달리 이스케이프 시퀀스 사용하지 않고도 줄바꿈 가능

- 공백도 그대로 적용됨

```js
let content = `안녕하세요:)
     이것은 템플릿 리터럴을 활용한
멀티라인 문자열입니다.`;

console.log(content);
```

```
안녕하세요:)
     이것은 템플릿 리터럴을 활용한
멀티라인 문자열입니다.
```

#### ✨ 표현식 삽입

- 템플릿 리터럴 내에서는 일반 문자열처럼 문자열 연산자를 사용하지 않고도 표현식 삽입을 활용하여 문자열 삽입 가능

- 평가 결과가 문자열이 아니라도 문자열로 강제 타입 변환 후 삽입

```js
let animal = "penguin";

console.log(`My favorite animal is a ${animal}.`);
// My favorite animal is a penguin.
```

- 일반 문자열에서의 표현식 삽입은 문자열로 취급되므로 주의할 것!

```js
console.log("My favorite animal is a ${animal}.");
// My favorite animal is a ${animal}.
```

### 📍 데이터 타입의 필요성

- 변수를 선언할 때

  - JS 엔진은 데이터 타입에 따라 확보해야 할 메모리 공간의 크기를 결정할 수 있음

- 값을 참조할 때

  - JS 엔진은 변수의 데이터 타입을 인식하여 한 번에 읽어 들여야 할 메모리 셀의 크기를 알 수 있음

- 값을 해석할 때
  - JS 엔진은 데이터 타입에 따라 메모리에 저장되어 있던 2진수를 어떻게 해석할지 결정할 수 있음

### 📍 동적 타이핑

#### 🔣 정적 타입 언어

- 변수 선언 시 할당할 데이터 타입을 사전에 선언해야 함

- 변수 선언 시점에 변수의 타입 결정 → 선언한 타입에 맞는 값만 할당 가능

- 컴파일 시점에 타입 체크 수행 후 통과 못하면 에러 발생

- 예) C, Java

#### 🔣 동적 타입 언어

- 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당 가능함

- 값을 할당하는 시점에 변수의 타입이 동적으로 결정 → 재할당을 통해 자유롭게 타입 변경 가능

> ✨**타입 추론**: 선언이 아닌 할당에 의해 타입 결정

- 문제점

  - 1. 변화하는 변수값을 추적하기 어려울 수 있음

  - 2. 개발자의 의도와 상관없이 JS 엔진에 의해 암묵적으로 타입이 자동으로 변환될 수 있음

  - ➡️ 유연성은 높지만 신뢰성은 떨어짐

- 예) 자바스크립트, 파이썬

#### ⚠️ 변수 사용 시 주의사항

```
1️⃣ 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.

2️⃣ 변수의 스코프는 최대한 좁게 만들어 부작용을 억제한다.

3️⃣ 전역변수는 최대한 사용하지 않는다.

4️⃣ 변수보다는 상수(const)를 사용해 값의 변경을 억제한다.

5️⃣ 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.
```
