## 📽️ 리액트의 역사

### 1️⃣ 2010년대 프런트앤드 개발 환경을 향한 페이스북의 도전

> **_2000년대_**

- `LAMP` Stacks
  - Linux, Aphache 웹 서버, MySQL, PHP를 활용한 웹 개발이 주를 이룸
- 사용하는 프레임워크(PHP, Ruby on Rails, Django 등)에 따라 차이가 있긴 하지만 대부분 아래와 같은 방식
  1. DB 에서 필요한 데이터를 불러온다.
  2. 웹 서버에서 HTML 페이지를 만들어 클라이언트에게 제공한다.
  3. 콘텐츠는 사용자나 기타 다른 환경에 따라 서버에서 동적으로 생성한다.
  4. 웹 브라우저는 이를 단순히 다운로드 후 렌더링하고, JS는 폼 처리와 같은 부수적인 역할만 수행한다.
- 프런트엔드는 서버에서 만든 HTML 페이지를 수동적으로 보여주기만 했다.

> **_2010: 리액트 개발 논의 단계_**

- jQuery의 등장
- 인터넷 익스플로러 8, local storage 지원
- 브라우저에서 WebSocket, Canvas(JS 그래픽 표현 지원), SVC(벡터 그래픽 표현), Geolocation(사용자 위치 파악) 등의 기능 지원
- ES5가 표준 스펙으로 자리 잡음

⬇️

- JS는 적극적으로 DOM(Document Object Model)을 수정해 사용자에게 다양한 인터렉션을 보여줌
- Ajax(Asynchronous JavaScript and XML)를 활용해 클라이언트에서도 서버와 통신해 데이터를 받아옴
- JS 코드가 점차 복잡해짐

⬇️

- AngularJS(Google)와 Backbone.js의 등장
- `MVVM`(Model-View-ViewModel), `MVC`(Model-View-Controller) 패턴 기반으로 복잡한 JS 코드 체계화 시도

> 페이스북이 리액트를 만들게 된 이유

- 전 세계적인 인기를 구가하는 SNS가 된 만큼 성능의 중요성이 높아짐
- 페이스북은 최대한 서버에서 렌더링하는 기술을 사용해 JS 번들 크기 축소를 위해 오랜 시간 노력하였음
  - JS의 코드 크기가 늘어날수록 다운로드, 파싱, 실행하는 브라우저의 부담이 증가했기 때문
  - JS를 반드시 필요한 곳에서만 제한적으로 사용하려고 노력함
- 그럼에도 JS 코드는 커지고, 서버 렌더링 처리 규모에는 한계가 존재하였음
  - 사용자가 글을 하나 올릴 때마다 서버에서 매번 새롭게 렌더링하는 상황 <br/>
    ➡️ 브라우저 전체가 다시 로딩되어 전체 페이지가 깜빡이거나 느리게 작동하는 문제 발생
- 실시간성을 강조하는 기능들 때문에 요구사항을 충족하면서 JS 의존성을 낮춰 번들 사이즈를 줄이는 것은 어려웠음

> 스파르탄 프로젝트

- 페이스북에게 웹의 중요성을 더욱 부각시킨 사건
- Apple의 강력한 앱 규제에 반발해 페이스북 iOS 앱 대신 애플의 사파리에서 작동할 수 있는 페이스북을 위해 만들어진 프로젝트
- 당시 HTML5는 표준만 잘 지키면 PC, 모바일 관계 없이 동일한 서비스의 가능성을 제공했음 <br/>
  ➡️ HTML5 기반으로 페이스북을 완전히 재작성하여 애플의 앱 스토어 규제에서 벗어나기 위한 `스파르탄 프로젝트`에 도입
- ⚠️ **_스파르탄 프로젝트의 실패_**
  - 이후 네티이브로 iOS, 안드로이드용 페이스북 앱을 개발하여 출시함
  - 네이티브로 만든 app이 HTML5로 만든 것보다 훨씬 빠르고 안정적이었기 때문

```
👩‍🏫 하지만 이러한 실패가 웹 생태계에 부정적인 역할을 미치지는 않았습니다!

- 웹 기술을 이용해 앱, 모바일, PC에서 동일한 UX를 제공하려는 시도
```

### 2️⃣ BoltJS의 등장과 한계

- 페이스북은 바닐라 JS, jQuery, Angular, Backbone.js로는 복잡한 페이스북의 요구사항을 만족하면서 좋은 UX 제공이 어렵다고 판단함

> BoltJS의 등장

- `createClass`를 통해 내부에 객체를 선언해 컴포넌트 생성
  - 이후 리액트 초기 버전의 `React.createClass`가 이어받음
  - BoltJS만으로 하나의 프레임워크를 구성하지 못하고 Javelin, View 같은 라이브러리를 함께 써서 구축된 프레임워크

> BoltJS 소스코드 삭제

- 실제 프로덕션 서비스에서 사용되지 못하고 돌연 삭제됨

> Fbolt; Functional Bolt

- 리액트의 시초
- 함수형을 지향하는 새로운 버전의 BoltJS
- 파격적인 프런트엔드 접근법의 등장
  ```
  애플리케이션에서의 API의 변화에 따라 무언가 변경되면
  단순히 UI를 초기화하고 새로 렌더링하자는 것
  ```
- 이전까지의 프레임워크들은 대부분 양방향 바인딩 구조였음

  - 모델과 뷰가 일접한 관계를 맺고 서로가 서로를 변경할 수 있는 구조
  - 코드를 작성하는 것은 간단했음
  - 변경된 DOM 추적 및 변경 원인 추적이 어려워 버그가 많이 발생하였음

- `Fbolt`의 경우 모델이 뷰를 변경하는 단방향 바인딩 구조 선택
  - 모델의 데이터가 변경되어 뷰가 변경되면 이전의 DOM을 버리고 새롭게 렌더링하는 방식

### 3️⃣ 페이스북 팀의 대안으로 떠오른 리액트

- `UFI`(Univeral Feedback Interface)를 구현하면서 시작되었음

  - 좋아요, 댓글 남기기 등이 채팅과 같은 반응 속도로 이루어져야 했음
  - 모든 포스트에 존재하는 만큼 포스트의 수가 늘어날 수록 버그 발생 가능성이 높아졌음

- JSX 구문과 Flux 패턴에 대한 아이디어 등장

⬇️

- 페이스북의 인스타그램 인수
  - 인스타그램의 웹 버전 구현 시 리액트를 채택하였음

### 4️⃣ 리액트에 대한 회의적인 의견과 비판

- JSConf US 2013에서 JSX(embedded XML)와 함께 공개되었음
- 처음에는 JSX 구문의 특징인 JS 코드 내에 HTML을 추가한다는 것에 반응이 좋지 않았음
  - HTML과 JS가 다른 파일에 존재하는 것이 CS 상 관심사 분리 원칙을 지키기 위한 기본으로 여겨졌기 때문

```
🧐 정말 리액트의 구조는 관심사 분리의 원칙을 따르지 않았을까?
```

- 당시의 관심사 분리는 HTML, CSS, JS가 각각 다른 폴더와 파일로 분리되어 있었음
  - 파일의 역할별로 관심사가 분리되는 것에 초점이 맞춰져 있었음
- 리액트의 경우 **컴포넌트 기반**으로 관심사가 `분리되어` 있었음
- 서로 다른 방식을 채택해 관심사를 분리하고 있었던 것!

```
👩‍🏫 페이스북 팀이 간과하고 있던 부분도 있습니다.
```

- 페이스북 팀은 복잡해져가는 웹 애플리케이션을 효율적으로 관리하기 위한 새로운 프레임워크에 초점을 맞추었음
- 하지만 JSX라는 새로운 문법과 내부에 혼재된 JS 코드에 대한 일반적인 웹 개발자의 거부감을 제대로 해소하지 못함

### 5️⃣ 드디어 빛을 보는 리액트

- 그럼에도 리액트의 접근 방식에 흥미를 느끼고 리액트를 도입하는 사람들이 생겨남
- 그들은 아래와 같은 특징을 장점으로 소개하였음
  - 리액트의 선언적인 인터페이스를 통해 컴포넌트 트리로 간단한 작성이 가능하다.
  - 어떤 컴포넌트의 렌더링이 필요한지 결정할 수 있다.
  - 필요하지 않은 영역에 대한 DOM 변경을 하지 않아 효율적인 개발이 가능했다.
  - 시간의 흐름에 따라 변경되는 데이터를 효율적으로 나타내기 위한 재사용 가능한 컴포넌트 생성을 할 수 있다.
  - 리액트를 활용해 렌더링을 생략하여 성능적인 이점을 가질 수 있다.

⬇️

- Yahoo!
  - 초기에는 C++과 HTML로 제작되었음 ➡️ 시간이 지나며 PHP와 JS 기반으로 마이그레이션
  - 기능이 추가되고 요구사항이 복잡해지면서 전통적인 MVC 패턴 개발의 한계를 느끼게 됨 <br/>
    ➡️ 리액트와 Flux 패턴 도입; 예측 가능한 데이터 흐름, 독립적인 컴포넌트 개발 등을 목표로 함
- Netflix
  - 원래 Java를 기반으로 만들어졌으나 최초 상호작용에 걸리는 시간과 웹 사이트 빌드에 오랜 시간이 걸림
  - 기능 추가 시에도 오랜 시간이 걸려 DX 상으로도 좋지 않았음
  - 새로운 UI에 맞춰 도입할 모던 프레임워크 선정을 위해 리액트와 백본 중 고민한 결과 아래와 같은 장점으로 리액트를 선정함
    - JS 코드의 크기 감소: 리액트는 상태에 따른 UI를 선언적으로 구현하여 간결한 코드 작성
    - 상대적으로 완만한 학습 곡선
  - 빠른 기능 추가
    - 기능 추가 및 빌드에 걸리는 시간이 Java 애플리케이션에 비해 빨랐음

⬇️

- React.js Conf에서 **_react-hot-loader_**, **_redux_** 등의 라이브러리가 공개됨
- 리액트의 전성기 시작!

### 🌟 리액트의 현재와 미래

- 리액트의 최초 공개 버전은 `0.3.0`, 현재 최신 버전은 `18.2.0` (2023 기준)
- 리액트는 Angular나 Vue 등의 라이브러리와 달리 웹 개발을 위한 프레임워크를 지향하지 않음

  - 따라서 함께 사용할 수 있는 다양한 라이브러리가 존재함
    |분야|라이브러리|
    |:--:|:--|
    |상태 관리|Redux, Zustand, Recoil, Jotai|
    |서버 사이드 렌더링|Next.js, Remix, Hydrogen|
    |애니메이션|Framer Motion, react-spring, React Move|
    |차트|Recharts, visx, nivo|
    |폼|React Hook Form, Formik, React Final Form|

- 리액트의 미래
  - 현재 리액트는 서버에서의 리액트 활용에 관심을 갖고 있음
  - 클라이언트에서는 할 수 없는 서버에서의 작업, 서버 환경이 가지고 있는 가능성에 무게를 두고 사버에서 작동할 수 있는 다양한 기능과 유스케이스를 추가할 예정
